// Code generated by protoc-gen-gogo.
// source: riak_kv.proto
// DO NOT EDIT!

/*
	Package riak_kv is a generated protocol buffer package.

	It is generated from these files:
		riak_kv.proto

	It has these top-level messages:
		RpbGetClientIdResp
		RpbSetClientIdReq
		RpbGetReq
		RpbGetResp
		RpbPutReq
		RpbPutResp
		RpbDelReq
		RpbListBucketsReq
		RpbListBucketsResp
		RpbListKeysReq
		RpbListKeysResp
		RpbMapRedReq
		RpbMapRedResp
		RpbIndexReq
		RpbIndexResp
		RpbIndexBodyResp
		RpbCSBucketReq
		RpbCSBucketResp
		RpbIndexObject
		RpbContent
		RpbLink
		RpbCounterUpdateReq
		RpbCounterUpdateResp
		RpbCounterGetReq
		RpbCounterGetResp
		RpbGetBucketKeyPreflistReq
		RpbGetBucketKeyPreflistResp
		RpbBucketKeyPreflistItem
		RpbCoverageReq
		RpbCoverageResp
		RpbCoverageEntry
*/
package riak_kv

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import riak "github.com/basho/riak-go-client/rpb/riak"

import github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RpbIndexReq_IndexQueryType int32

const (
	RpbIndexReq_eq    RpbIndexReq_IndexQueryType = 0
	RpbIndexReq_range RpbIndexReq_IndexQueryType = 1
)

var RpbIndexReq_IndexQueryType_name = map[int32]string{
	0: "eq",
	1: "range",
}
var RpbIndexReq_IndexQueryType_value = map[string]int32{
	"eq":    0,
	"range": 1,
}

func (x RpbIndexReq_IndexQueryType) Enum() *RpbIndexReq_IndexQueryType {
	p := new(RpbIndexReq_IndexQueryType)
	*p = x
	return p
}
func (x RpbIndexReq_IndexQueryType) String() string {
	return proto.EnumName(RpbIndexReq_IndexQueryType_name, int32(x))
}
func (x *RpbIndexReq_IndexQueryType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RpbIndexReq_IndexQueryType_value, data, "RpbIndexReq_IndexQueryType")
	if err != nil {
		return err
	}
	*x = RpbIndexReq_IndexQueryType(value)
	return nil
}
func (RpbIndexReq_IndexQueryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRiakKv, []int{13, 0}
}

// Get ClientId Request - no message defined, just send RpbGetClientIdReq message code
type RpbGetClientIdResp struct {
	ClientId         []byte `protobuf:"bytes,1,req,name=client_id" json:"client_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RpbGetClientIdResp) Reset()                    { *m = RpbGetClientIdResp{} }
func (m *RpbGetClientIdResp) String() string            { return proto.CompactTextString(m) }
func (*RpbGetClientIdResp) ProtoMessage()               {}
func (*RpbGetClientIdResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{0} }

func (m *RpbGetClientIdResp) GetClientId() []byte {
	if m != nil {
		return m.ClientId
	}
	return nil
}

type RpbSetClientIdReq struct {
	ClientId         []byte `protobuf:"bytes,1,req,name=client_id" json:"client_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RpbSetClientIdReq) Reset()                    { *m = RpbSetClientIdReq{} }
func (m *RpbSetClientIdReq) String() string            { return proto.CompactTextString(m) }
func (*RpbSetClientIdReq) ProtoMessage()               {}
func (*RpbSetClientIdReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{1} }

func (m *RpbSetClientIdReq) GetClientId() []byte {
	if m != nil {
		return m.ClientId
	}
	return nil
}

// Get Request - retrieve bucket/key
type RpbGetReq struct {
	Bucket           []byte  `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Key              []byte  `protobuf:"bytes,2,req,name=key" json:"key,omitempty"`
	R                *uint32 `protobuf:"varint,3,opt,name=r" json:"r,omitempty"`
	Pr               *uint32 `protobuf:"varint,4,opt,name=pr" json:"pr,omitempty"`
	BasicQuorum      *bool   `protobuf:"varint,5,opt,name=basic_quorum" json:"basic_quorum,omitempty"`
	NotfoundOk       *bool   `protobuf:"varint,6,opt,name=notfound_ok" json:"notfound_ok,omitempty"`
	IfModified       []byte  `protobuf:"bytes,7,opt,name=if_modified" json:"if_modified,omitempty"`
	Head             *bool   `protobuf:"varint,8,opt,name=head" json:"head,omitempty"`
	Deletedvclock    *bool   `protobuf:"varint,9,opt,name=deletedvclock" json:"deletedvclock,omitempty"`
	Timeout          *uint32 `protobuf:"varint,10,opt,name=timeout" json:"timeout,omitempty"`
	SloppyQuorum     *bool   `protobuf:"varint,11,opt,name=sloppy_quorum" json:"sloppy_quorum,omitempty"`
	NVal             *uint32 `protobuf:"varint,12,opt,name=n_val" json:"n_val,omitempty"`
	Type             []byte  `protobuf:"bytes,13,opt,name=type" json:"type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RpbGetReq) Reset()                    { *m = RpbGetReq{} }
func (m *RpbGetReq) String() string            { return proto.CompactTextString(m) }
func (*RpbGetReq) ProtoMessage()               {}
func (*RpbGetReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{2} }

func (m *RpbGetReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *RpbGetReq) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RpbGetReq) GetR() uint32 {
	if m != nil && m.R != nil {
		return *m.R
	}
	return 0
}

func (m *RpbGetReq) GetPr() uint32 {
	if m != nil && m.Pr != nil {
		return *m.Pr
	}
	return 0
}

func (m *RpbGetReq) GetBasicQuorum() bool {
	if m != nil && m.BasicQuorum != nil {
		return *m.BasicQuorum
	}
	return false
}

func (m *RpbGetReq) GetNotfoundOk() bool {
	if m != nil && m.NotfoundOk != nil {
		return *m.NotfoundOk
	}
	return false
}

func (m *RpbGetReq) GetIfModified() []byte {
	if m != nil {
		return m.IfModified
	}
	return nil
}

func (m *RpbGetReq) GetHead() bool {
	if m != nil && m.Head != nil {
		return *m.Head
	}
	return false
}

func (m *RpbGetReq) GetDeletedvclock() bool {
	if m != nil && m.Deletedvclock != nil {
		return *m.Deletedvclock
	}
	return false
}

func (m *RpbGetReq) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *RpbGetReq) GetSloppyQuorum() bool {
	if m != nil && m.SloppyQuorum != nil {
		return *m.SloppyQuorum
	}
	return false
}

func (m *RpbGetReq) GetNVal() uint32 {
	if m != nil && m.NVal != nil {
		return *m.NVal
	}
	return 0
}

func (m *RpbGetReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

// Get Response - if the record was not found there will be no content/vclock
type RpbGetResp struct {
	Content          []*RpbContent `protobuf:"bytes,1,rep,name=content" json:"content,omitempty"`
	Vclock           []byte        `protobuf:"bytes,2,opt,name=vclock" json:"vclock,omitempty"`
	Unchanged        *bool         `protobuf:"varint,3,opt,name=unchanged" json:"unchanged,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *RpbGetResp) Reset()                    { *m = RpbGetResp{} }
func (m *RpbGetResp) String() string            { return proto.CompactTextString(m) }
func (*RpbGetResp) ProtoMessage()               {}
func (*RpbGetResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{3} }

func (m *RpbGetResp) GetContent() []*RpbContent {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *RpbGetResp) GetVclock() []byte {
	if m != nil {
		return m.Vclock
	}
	return nil
}

func (m *RpbGetResp) GetUnchanged() bool {
	if m != nil && m.Unchanged != nil {
		return *m.Unchanged
	}
	return false
}

// Put request - if options.return_body is set then the updated metadata/data for
//               the key will be returned.
type RpbPutReq struct {
	Bucket           []byte      `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Key              []byte      `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Vclock           []byte      `protobuf:"bytes,3,opt,name=vclock" json:"vclock,omitempty"`
	Content          *RpbContent `protobuf:"bytes,4,req,name=content" json:"content,omitempty"`
	W                *uint32     `protobuf:"varint,5,opt,name=w" json:"w,omitempty"`
	Dw               *uint32     `protobuf:"varint,6,opt,name=dw" json:"dw,omitempty"`
	ReturnBody       *bool       `protobuf:"varint,7,opt,name=return_body" json:"return_body,omitempty"`
	Pw               *uint32     `protobuf:"varint,8,opt,name=pw" json:"pw,omitempty"`
	IfNotModified    *bool       `protobuf:"varint,9,opt,name=if_not_modified" json:"if_not_modified,omitempty"`
	IfNoneMatch      *bool       `protobuf:"varint,10,opt,name=if_none_match" json:"if_none_match,omitempty"`
	ReturnHead       *bool       `protobuf:"varint,11,opt,name=return_head" json:"return_head,omitempty"`
	Timeout          *uint32     `protobuf:"varint,12,opt,name=timeout" json:"timeout,omitempty"`
	Asis             *bool       `protobuf:"varint,13,opt,name=asis" json:"asis,omitempty"`
	SloppyQuorum     *bool       `protobuf:"varint,14,opt,name=sloppy_quorum" json:"sloppy_quorum,omitempty"`
	NVal             *uint32     `protobuf:"varint,15,opt,name=n_val" json:"n_val,omitempty"`
	Type             []byte      `protobuf:"bytes,16,opt,name=type" json:"type,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *RpbPutReq) Reset()                    { *m = RpbPutReq{} }
func (m *RpbPutReq) String() string            { return proto.CompactTextString(m) }
func (*RpbPutReq) ProtoMessage()               {}
func (*RpbPutReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{4} }

func (m *RpbPutReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *RpbPutReq) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RpbPutReq) GetVclock() []byte {
	if m != nil {
		return m.Vclock
	}
	return nil
}

func (m *RpbPutReq) GetContent() *RpbContent {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *RpbPutReq) GetW() uint32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *RpbPutReq) GetDw() uint32 {
	if m != nil && m.Dw != nil {
		return *m.Dw
	}
	return 0
}

func (m *RpbPutReq) GetReturnBody() bool {
	if m != nil && m.ReturnBody != nil {
		return *m.ReturnBody
	}
	return false
}

func (m *RpbPutReq) GetPw() uint32 {
	if m != nil && m.Pw != nil {
		return *m.Pw
	}
	return 0
}

func (m *RpbPutReq) GetIfNotModified() bool {
	if m != nil && m.IfNotModified != nil {
		return *m.IfNotModified
	}
	return false
}

func (m *RpbPutReq) GetIfNoneMatch() bool {
	if m != nil && m.IfNoneMatch != nil {
		return *m.IfNoneMatch
	}
	return false
}

func (m *RpbPutReq) GetReturnHead() bool {
	if m != nil && m.ReturnHead != nil {
		return *m.ReturnHead
	}
	return false
}

func (m *RpbPutReq) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *RpbPutReq) GetAsis() bool {
	if m != nil && m.Asis != nil {
		return *m.Asis
	}
	return false
}

func (m *RpbPutReq) GetSloppyQuorum() bool {
	if m != nil && m.SloppyQuorum != nil {
		return *m.SloppyQuorum
	}
	return false
}

func (m *RpbPutReq) GetNVal() uint32 {
	if m != nil && m.NVal != nil {
		return *m.NVal
	}
	return 0
}

func (m *RpbPutReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

// Put response - same as get response with optional key if one was generated
type RpbPutResp struct {
	Content          []*RpbContent `protobuf:"bytes,1,rep,name=content" json:"content,omitempty"`
	Vclock           []byte        `protobuf:"bytes,2,opt,name=vclock" json:"vclock,omitempty"`
	Key              []byte        `protobuf:"bytes,3,opt,name=key" json:"key,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *RpbPutResp) Reset()                    { *m = RpbPutResp{} }
func (m *RpbPutResp) String() string            { return proto.CompactTextString(m) }
func (*RpbPutResp) ProtoMessage()               {}
func (*RpbPutResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{5} }

func (m *RpbPutResp) GetContent() []*RpbContent {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *RpbPutResp) GetVclock() []byte {
	if m != nil {
		return m.Vclock
	}
	return nil
}

func (m *RpbPutResp) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

// Delete request
type RpbDelReq struct {
	Bucket           []byte  `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Key              []byte  `protobuf:"bytes,2,req,name=key" json:"key,omitempty"`
	Rw               *uint32 `protobuf:"varint,3,opt,name=rw" json:"rw,omitempty"`
	Vclock           []byte  `protobuf:"bytes,4,opt,name=vclock" json:"vclock,omitempty"`
	R                *uint32 `protobuf:"varint,5,opt,name=r" json:"r,omitempty"`
	W                *uint32 `protobuf:"varint,6,opt,name=w" json:"w,omitempty"`
	Pr               *uint32 `protobuf:"varint,7,opt,name=pr" json:"pr,omitempty"`
	Pw               *uint32 `protobuf:"varint,8,opt,name=pw" json:"pw,omitempty"`
	Dw               *uint32 `protobuf:"varint,9,opt,name=dw" json:"dw,omitempty"`
	Timeout          *uint32 `protobuf:"varint,10,opt,name=timeout" json:"timeout,omitempty"`
	SloppyQuorum     *bool   `protobuf:"varint,11,opt,name=sloppy_quorum" json:"sloppy_quorum,omitempty"`
	NVal             *uint32 `protobuf:"varint,12,opt,name=n_val" json:"n_val,omitempty"`
	Type             []byte  `protobuf:"bytes,13,opt,name=type" json:"type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RpbDelReq) Reset()                    { *m = RpbDelReq{} }
func (m *RpbDelReq) String() string            { return proto.CompactTextString(m) }
func (*RpbDelReq) ProtoMessage()               {}
func (*RpbDelReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{6} }

func (m *RpbDelReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *RpbDelReq) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RpbDelReq) GetRw() uint32 {
	if m != nil && m.Rw != nil {
		return *m.Rw
	}
	return 0
}

func (m *RpbDelReq) GetVclock() []byte {
	if m != nil {
		return m.Vclock
	}
	return nil
}

func (m *RpbDelReq) GetR() uint32 {
	if m != nil && m.R != nil {
		return *m.R
	}
	return 0
}

func (m *RpbDelReq) GetW() uint32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *RpbDelReq) GetPr() uint32 {
	if m != nil && m.Pr != nil {
		return *m.Pr
	}
	return 0
}

func (m *RpbDelReq) GetPw() uint32 {
	if m != nil && m.Pw != nil {
		return *m.Pw
	}
	return 0
}

func (m *RpbDelReq) GetDw() uint32 {
	if m != nil && m.Dw != nil {
		return *m.Dw
	}
	return 0
}

func (m *RpbDelReq) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *RpbDelReq) GetSloppyQuorum() bool {
	if m != nil && m.SloppyQuorum != nil {
		return *m.SloppyQuorum
	}
	return false
}

func (m *RpbDelReq) GetNVal() uint32 {
	if m != nil && m.NVal != nil {
		return *m.NVal
	}
	return 0
}

func (m *RpbDelReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

// List buckets request
type RpbListBucketsReq struct {
	Timeout          *uint32 `protobuf:"varint,1,opt,name=timeout" json:"timeout,omitempty"`
	Stream           *bool   `protobuf:"varint,2,opt,name=stream" json:"stream,omitempty"`
	Type             []byte  `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RpbListBucketsReq) Reset()                    { *m = RpbListBucketsReq{} }
func (m *RpbListBucketsReq) String() string            { return proto.CompactTextString(m) }
func (*RpbListBucketsReq) ProtoMessage()               {}
func (*RpbListBucketsReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{7} }

func (m *RpbListBucketsReq) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *RpbListBucketsReq) GetStream() bool {
	if m != nil && m.Stream != nil {
		return *m.Stream
	}
	return false
}

func (m *RpbListBucketsReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

// List buckets response - one or more of these packets will be sent
// the last one will have done set true (and may not have any buckets in it)
type RpbListBucketsResp struct {
	Buckets          [][]byte `protobuf:"bytes,1,rep,name=buckets" json:"buckets,omitempty"`
	Done             *bool    `protobuf:"varint,2,opt,name=done" json:"done,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *RpbListBucketsResp) Reset()                    { *m = RpbListBucketsResp{} }
func (m *RpbListBucketsResp) String() string            { return proto.CompactTextString(m) }
func (*RpbListBucketsResp) ProtoMessage()               {}
func (*RpbListBucketsResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{8} }

func (m *RpbListBucketsResp) GetBuckets() [][]byte {
	if m != nil {
		return m.Buckets
	}
	return nil
}

func (m *RpbListBucketsResp) GetDone() bool {
	if m != nil && m.Done != nil {
		return *m.Done
	}
	return false
}

// List keys in bucket request
type RpbListKeysReq struct {
	Bucket           []byte  `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Timeout          *uint32 `protobuf:"varint,2,opt,name=timeout" json:"timeout,omitempty"`
	Type             []byte  `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RpbListKeysReq) Reset()                    { *m = RpbListKeysReq{} }
func (m *RpbListKeysReq) String() string            { return proto.CompactTextString(m) }
func (*RpbListKeysReq) ProtoMessage()               {}
func (*RpbListKeysReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{9} }

func (m *RpbListKeysReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *RpbListKeysReq) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *RpbListKeysReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

// List keys in bucket response - one or more of these packets will be sent
// the last one will have done set true (and may not have any keys in it)
type RpbListKeysResp struct {
	Keys             [][]byte `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	Done             *bool    `protobuf:"varint,2,opt,name=done" json:"done,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *RpbListKeysResp) Reset()                    { *m = RpbListKeysResp{} }
func (m *RpbListKeysResp) String() string            { return proto.CompactTextString(m) }
func (*RpbListKeysResp) ProtoMessage()               {}
func (*RpbListKeysResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{10} }

func (m *RpbListKeysResp) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *RpbListKeysResp) GetDone() bool {
	if m != nil && m.Done != nil {
		return *m.Done
	}
	return false
}

// Map/Reduce request
type RpbMapRedReq struct {
	Request          []byte `protobuf:"bytes,1,req,name=request" json:"request,omitempty"`
	ContentType      []byte `protobuf:"bytes,2,req,name=content_type" json:"content_type,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RpbMapRedReq) Reset()                    { *m = RpbMapRedReq{} }
func (m *RpbMapRedReq) String() string            { return proto.CompactTextString(m) }
func (*RpbMapRedReq) ProtoMessage()               {}
func (*RpbMapRedReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{11} }

func (m *RpbMapRedReq) GetRequest() []byte {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *RpbMapRedReq) GetContentType() []byte {
	if m != nil {
		return m.ContentType
	}
	return nil
}

// Map/Reduce response
// one or more of these packets will be sent the last one will have done set
// true (and may not have phase/data in it)
type RpbMapRedResp struct {
	Phase            *uint32 `protobuf:"varint,1,opt,name=phase" json:"phase,omitempty"`
	Response         []byte  `protobuf:"bytes,2,opt,name=response" json:"response,omitempty"`
	Done             *bool   `protobuf:"varint,3,opt,name=done" json:"done,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RpbMapRedResp) Reset()                    { *m = RpbMapRedResp{} }
func (m *RpbMapRedResp) String() string            { return proto.CompactTextString(m) }
func (*RpbMapRedResp) ProtoMessage()               {}
func (*RpbMapRedResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{12} }

func (m *RpbMapRedResp) GetPhase() uint32 {
	if m != nil && m.Phase != nil {
		return *m.Phase
	}
	return 0
}

func (m *RpbMapRedResp) GetResponse() []byte {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *RpbMapRedResp) GetDone() bool {
	if m != nil && m.Done != nil {
		return *m.Done
	}
	return false
}

// Secondary Index query request
type RpbIndexReq struct {
	Bucket       []byte                      `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Index        []byte                      `protobuf:"bytes,2,req,name=index" json:"index,omitempty"`
	Qtype        *RpbIndexReq_IndexQueryType `protobuf:"varint,3,req,name=qtype,enum=RpbIndexReq_IndexQueryType" json:"qtype,omitempty"`
	Key          []byte                      `protobuf:"bytes,4,opt,name=key" json:"key,omitempty"`
	RangeMin     []byte                      `protobuf:"bytes,5,opt,name=range_min" json:"range_min,omitempty"`
	RangeMax     []byte                      `protobuf:"bytes,6,opt,name=range_max" json:"range_max,omitempty"`
	ReturnTerms  *bool                       `protobuf:"varint,7,opt,name=return_terms" json:"return_terms,omitempty"`
	Stream       *bool                       `protobuf:"varint,8,opt,name=stream" json:"stream,omitempty"`
	MaxResults   *uint32                     `protobuf:"varint,9,opt,name=max_results" json:"max_results,omitempty"`
	Continuation []byte                      `protobuf:"bytes,10,opt,name=continuation" json:"continuation,omitempty"`
	Timeout      *uint32                     `protobuf:"varint,11,opt,name=timeout" json:"timeout,omitempty"`
	Type         []byte                      `protobuf:"bytes,12,opt,name=type" json:"type,omitempty"`
	TermRegex    []byte                      `protobuf:"bytes,13,opt,name=term_regex" json:"term_regex,omitempty"`
	// Whether to use pagination sort for non-paginated queries
	PaginationSort *bool `protobuf:"varint,14,opt,name=pagination_sort" json:"pagination_sort,omitempty"`
	// parallel extraction extension
	CoverContext     []byte `protobuf:"bytes,15,opt,name=cover_context" json:"cover_context,omitempty"`
	ReturnBody       *bool  `protobuf:"varint,16,opt,name=return_body" json:"return_body,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RpbIndexReq) Reset()                    { *m = RpbIndexReq{} }
func (m *RpbIndexReq) String() string            { return proto.CompactTextString(m) }
func (*RpbIndexReq) ProtoMessage()               {}
func (*RpbIndexReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{13} }

func (m *RpbIndexReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *RpbIndexReq) GetIndex() []byte {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *RpbIndexReq) GetQtype() RpbIndexReq_IndexQueryType {
	if m != nil && m.Qtype != nil {
		return *m.Qtype
	}
	return RpbIndexReq_eq
}

func (m *RpbIndexReq) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RpbIndexReq) GetRangeMin() []byte {
	if m != nil {
		return m.RangeMin
	}
	return nil
}

func (m *RpbIndexReq) GetRangeMax() []byte {
	if m != nil {
		return m.RangeMax
	}
	return nil
}

func (m *RpbIndexReq) GetReturnTerms() bool {
	if m != nil && m.ReturnTerms != nil {
		return *m.ReturnTerms
	}
	return false
}

func (m *RpbIndexReq) GetStream() bool {
	if m != nil && m.Stream != nil {
		return *m.Stream
	}
	return false
}

func (m *RpbIndexReq) GetMaxResults() uint32 {
	if m != nil && m.MaxResults != nil {
		return *m.MaxResults
	}
	return 0
}

func (m *RpbIndexReq) GetContinuation() []byte {
	if m != nil {
		return m.Continuation
	}
	return nil
}

func (m *RpbIndexReq) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *RpbIndexReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *RpbIndexReq) GetTermRegex() []byte {
	if m != nil {
		return m.TermRegex
	}
	return nil
}

func (m *RpbIndexReq) GetPaginationSort() bool {
	if m != nil && m.PaginationSort != nil {
		return *m.PaginationSort
	}
	return false
}

func (m *RpbIndexReq) GetCoverContext() []byte {
	if m != nil {
		return m.CoverContext
	}
	return nil
}

func (m *RpbIndexReq) GetReturnBody() bool {
	if m != nil && m.ReturnBody != nil {
		return *m.ReturnBody
	}
	return false
}

// Secondary Index query response
type RpbIndexResp struct {
	Keys             [][]byte        `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	Results          []*riak.RpbPair `protobuf:"bytes,2,rep,name=results" json:"results,omitempty"`
	Continuation     []byte          `protobuf:"bytes,3,opt,name=continuation" json:"continuation,omitempty"`
	Done             *bool           `protobuf:"varint,4,opt,name=done" json:"done,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *RpbIndexResp) Reset()                    { *m = RpbIndexResp{} }
func (m *RpbIndexResp) String() string            { return proto.CompactTextString(m) }
func (*RpbIndexResp) ProtoMessage()               {}
func (*RpbIndexResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{14} }

func (m *RpbIndexResp) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *RpbIndexResp) GetResults() []*riak.RpbPair {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *RpbIndexResp) GetContinuation() []byte {
	if m != nil {
		return m.Continuation
	}
	return nil
}

func (m *RpbIndexResp) GetDone() bool {
	if m != nil && m.Done != nil {
		return *m.Done
	}
	return false
}

// Stolen from CS bucket response, to be used when return_body=true
type RpbIndexBodyResp struct {
	Objects          []*RpbIndexObject `protobuf:"bytes,1,rep,name=objects" json:"objects,omitempty"`
	Continuation     []byte            `protobuf:"bytes,2,opt,name=continuation" json:"continuation,omitempty"`
	Done             *bool             `protobuf:"varint,3,opt,name=done" json:"done,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *RpbIndexBodyResp) Reset()                    { *m = RpbIndexBodyResp{} }
func (m *RpbIndexBodyResp) String() string            { return proto.CompactTextString(m) }
func (*RpbIndexBodyResp) ProtoMessage()               {}
func (*RpbIndexBodyResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{15} }

func (m *RpbIndexBodyResp) GetObjects() []*RpbIndexObject {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *RpbIndexBodyResp) GetContinuation() []byte {
	if m != nil {
		return m.Continuation
	}
	return nil
}

func (m *RpbIndexBodyResp) GetDone() bool {
	if m != nil && m.Done != nil {
		return *m.Done
	}
	return false
}

// added solely for riak_cs currently
// for folding over a bucket and returning
// objects.
type RpbCSBucketReq struct {
	Bucket       []byte  `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	StartKey     []byte  `protobuf:"bytes,2,req,name=start_key" json:"start_key,omitempty"`
	EndKey       []byte  `protobuf:"bytes,3,opt,name=end_key" json:"end_key,omitempty"`
	StartIncl    *bool   `protobuf:"varint,4,opt,name=start_incl,def=1" json:"start_incl,omitempty"`
	EndIncl      *bool   `protobuf:"varint,5,opt,name=end_incl,def=0" json:"end_incl,omitempty"`
	Continuation []byte  `protobuf:"bytes,6,opt,name=continuation" json:"continuation,omitempty"`
	MaxResults   *uint32 `protobuf:"varint,7,opt,name=max_results" json:"max_results,omitempty"`
	Timeout      *uint32 `protobuf:"varint,8,opt,name=timeout" json:"timeout,omitempty"`
	Type         []byte  `protobuf:"bytes,9,opt,name=type" json:"type,omitempty"`
	// parallel extraction extension
	CoverContext     []byte `protobuf:"bytes,10,opt,name=cover_context" json:"cover_context,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RpbCSBucketReq) Reset()                    { *m = RpbCSBucketReq{} }
func (m *RpbCSBucketReq) String() string            { return proto.CompactTextString(m) }
func (*RpbCSBucketReq) ProtoMessage()               {}
func (*RpbCSBucketReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{16} }

const Default_RpbCSBucketReq_StartIncl bool = true
const Default_RpbCSBucketReq_EndIncl bool = false

func (m *RpbCSBucketReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *RpbCSBucketReq) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *RpbCSBucketReq) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *RpbCSBucketReq) GetStartIncl() bool {
	if m != nil && m.StartIncl != nil {
		return *m.StartIncl
	}
	return Default_RpbCSBucketReq_StartIncl
}

func (m *RpbCSBucketReq) GetEndIncl() bool {
	if m != nil && m.EndIncl != nil {
		return *m.EndIncl
	}
	return Default_RpbCSBucketReq_EndIncl
}

func (m *RpbCSBucketReq) GetContinuation() []byte {
	if m != nil {
		return m.Continuation
	}
	return nil
}

func (m *RpbCSBucketReq) GetMaxResults() uint32 {
	if m != nil && m.MaxResults != nil {
		return *m.MaxResults
	}
	return 0
}

func (m *RpbCSBucketReq) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *RpbCSBucketReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *RpbCSBucketReq) GetCoverContext() []byte {
	if m != nil {
		return m.CoverContext
	}
	return nil
}

// return for CS bucket fold
type RpbCSBucketResp struct {
	Objects          []*RpbIndexObject `protobuf:"bytes,1,rep,name=objects" json:"objects,omitempty"`
	Continuation     []byte            `protobuf:"bytes,2,opt,name=continuation" json:"continuation,omitempty"`
	Done             *bool             `protobuf:"varint,3,opt,name=done" json:"done,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *RpbCSBucketResp) Reset()                    { *m = RpbCSBucketResp{} }
func (m *RpbCSBucketResp) String() string            { return proto.CompactTextString(m) }
func (*RpbCSBucketResp) ProtoMessage()               {}
func (*RpbCSBucketResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{17} }

func (m *RpbCSBucketResp) GetObjects() []*RpbIndexObject {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *RpbCSBucketResp) GetContinuation() []byte {
	if m != nil {
		return m.Continuation
	}
	return nil
}

func (m *RpbCSBucketResp) GetDone() bool {
	if m != nil && m.Done != nil {
		return *m.Done
	}
	return false
}

type RpbIndexObject struct {
	Key              []byte      `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Object           *RpbGetResp `protobuf:"bytes,2,req,name=object" json:"object,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *RpbIndexObject) Reset()                    { *m = RpbIndexObject{} }
func (m *RpbIndexObject) String() string            { return proto.CompactTextString(m) }
func (*RpbIndexObject) ProtoMessage()               {}
func (*RpbIndexObject) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{18} }

func (m *RpbIndexObject) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RpbIndexObject) GetObject() *RpbGetResp {
	if m != nil {
		return m.Object
	}
	return nil
}

// Content message included in get/put responses
// Holds the value and associated metadata
type RpbContent struct {
	Value            []byte          `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	ContentType      []byte          `protobuf:"bytes,2,opt,name=content_type" json:"content_type,omitempty"`
	Charset          []byte          `protobuf:"bytes,3,opt,name=charset" json:"charset,omitempty"`
	ContentEncoding  []byte          `protobuf:"bytes,4,opt,name=content_encoding" json:"content_encoding,omitempty"`
	Vtag             []byte          `protobuf:"bytes,5,opt,name=vtag" json:"vtag,omitempty"`
	Links            []*RpbLink      `protobuf:"bytes,6,rep,name=links" json:"links,omitempty"`
	LastMod          *uint32         `protobuf:"varint,7,opt,name=last_mod" json:"last_mod,omitempty"`
	LastModUsecs     *uint32         `protobuf:"varint,8,opt,name=last_mod_usecs" json:"last_mod_usecs,omitempty"`
	Usermeta         []*riak.RpbPair `protobuf:"bytes,9,rep,name=usermeta" json:"usermeta,omitempty"`
	Indexes          []*riak.RpbPair `protobuf:"bytes,10,rep,name=indexes" json:"indexes,omitempty"`
	Deleted          *bool           `protobuf:"varint,11,opt,name=deleted" json:"deleted,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *RpbContent) Reset()                    { *m = RpbContent{} }
func (m *RpbContent) String() string            { return proto.CompactTextString(m) }
func (*RpbContent) ProtoMessage()               {}
func (*RpbContent) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{19} }

func (m *RpbContent) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RpbContent) GetContentType() []byte {
	if m != nil {
		return m.ContentType
	}
	return nil
}

func (m *RpbContent) GetCharset() []byte {
	if m != nil {
		return m.Charset
	}
	return nil
}

func (m *RpbContent) GetContentEncoding() []byte {
	if m != nil {
		return m.ContentEncoding
	}
	return nil
}

func (m *RpbContent) GetVtag() []byte {
	if m != nil {
		return m.Vtag
	}
	return nil
}

func (m *RpbContent) GetLinks() []*RpbLink {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *RpbContent) GetLastMod() uint32 {
	if m != nil && m.LastMod != nil {
		return *m.LastMod
	}
	return 0
}

func (m *RpbContent) GetLastModUsecs() uint32 {
	if m != nil && m.LastModUsecs != nil {
		return *m.LastModUsecs
	}
	return 0
}

func (m *RpbContent) GetUsermeta() []*riak.RpbPair {
	if m != nil {
		return m.Usermeta
	}
	return nil
}

func (m *RpbContent) GetIndexes() []*riak.RpbPair {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *RpbContent) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

// Link metadata
type RpbLink struct {
	Bucket           []byte `protobuf:"bytes,1,opt,name=bucket" json:"bucket,omitempty"`
	Key              []byte `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Tag              []byte `protobuf:"bytes,3,opt,name=tag" json:"tag,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RpbLink) Reset()                    { *m = RpbLink{} }
func (m *RpbLink) String() string            { return proto.CompactTextString(m) }
func (*RpbLink) ProtoMessage()               {}
func (*RpbLink) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{20} }

func (m *RpbLink) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *RpbLink) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RpbLink) GetTag() []byte {
	if m != nil {
		return m.Tag
	}
	return nil
}

// Counter update request
type RpbCounterUpdateReq struct {
	Bucket           []byte  `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Key              []byte  `protobuf:"bytes,2,req,name=key" json:"key,omitempty"`
	Amount           *int64  `protobuf:"zigzag64,3,req,name=amount" json:"amount,omitempty"`
	W                *uint32 `protobuf:"varint,4,opt,name=w" json:"w,omitempty"`
	Dw               *uint32 `protobuf:"varint,5,opt,name=dw" json:"dw,omitempty"`
	Pw               *uint32 `protobuf:"varint,6,opt,name=pw" json:"pw,omitempty"`
	Returnvalue      *bool   `protobuf:"varint,7,opt,name=returnvalue" json:"returnvalue,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RpbCounterUpdateReq) Reset()                    { *m = RpbCounterUpdateReq{} }
func (m *RpbCounterUpdateReq) String() string            { return proto.CompactTextString(m) }
func (*RpbCounterUpdateReq) ProtoMessage()               {}
func (*RpbCounterUpdateReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{21} }

func (m *RpbCounterUpdateReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *RpbCounterUpdateReq) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RpbCounterUpdateReq) GetAmount() int64 {
	if m != nil && m.Amount != nil {
		return *m.Amount
	}
	return 0
}

func (m *RpbCounterUpdateReq) GetW() uint32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *RpbCounterUpdateReq) GetDw() uint32 {
	if m != nil && m.Dw != nil {
		return *m.Dw
	}
	return 0
}

func (m *RpbCounterUpdateReq) GetPw() uint32 {
	if m != nil && m.Pw != nil {
		return *m.Pw
	}
	return 0
}

func (m *RpbCounterUpdateReq) GetReturnvalue() bool {
	if m != nil && m.Returnvalue != nil {
		return *m.Returnvalue
	}
	return false
}

// Counter update response? No message | error response
type RpbCounterUpdateResp struct {
	Value            *int64 `protobuf:"zigzag64,1,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RpbCounterUpdateResp) Reset()                    { *m = RpbCounterUpdateResp{} }
func (m *RpbCounterUpdateResp) String() string            { return proto.CompactTextString(m) }
func (*RpbCounterUpdateResp) ProtoMessage()               {}
func (*RpbCounterUpdateResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{22} }

func (m *RpbCounterUpdateResp) GetValue() int64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

// counter value
type RpbCounterGetReq struct {
	Bucket           []byte  `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Key              []byte  `protobuf:"bytes,2,req,name=key" json:"key,omitempty"`
	R                *uint32 `protobuf:"varint,3,opt,name=r" json:"r,omitempty"`
	Pr               *uint32 `protobuf:"varint,4,opt,name=pr" json:"pr,omitempty"`
	BasicQuorum      *bool   `protobuf:"varint,5,opt,name=basic_quorum" json:"basic_quorum,omitempty"`
	NotfoundOk       *bool   `protobuf:"varint,6,opt,name=notfound_ok" json:"notfound_ok,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RpbCounterGetReq) Reset()                    { *m = RpbCounterGetReq{} }
func (m *RpbCounterGetReq) String() string            { return proto.CompactTextString(m) }
func (*RpbCounterGetReq) ProtoMessage()               {}
func (*RpbCounterGetReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{23} }

func (m *RpbCounterGetReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *RpbCounterGetReq) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RpbCounterGetReq) GetR() uint32 {
	if m != nil && m.R != nil {
		return *m.R
	}
	return 0
}

func (m *RpbCounterGetReq) GetPr() uint32 {
	if m != nil && m.Pr != nil {
		return *m.Pr
	}
	return 0
}

func (m *RpbCounterGetReq) GetBasicQuorum() bool {
	if m != nil && m.BasicQuorum != nil {
		return *m.BasicQuorum
	}
	return false
}

func (m *RpbCounterGetReq) GetNotfoundOk() bool {
	if m != nil && m.NotfoundOk != nil {
		return *m.NotfoundOk
	}
	return false
}

// Counter value response
type RpbCounterGetResp struct {
	Value            *int64 `protobuf:"zigzag64,1,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RpbCounterGetResp) Reset()                    { *m = RpbCounterGetResp{} }
func (m *RpbCounterGetResp) String() string            { return proto.CompactTextString(m) }
func (*RpbCounterGetResp) ProtoMessage()               {}
func (*RpbCounterGetResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{24} }

func (m *RpbCounterGetResp) GetValue() int64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

// Get bucket-key preflist request
type RpbGetBucketKeyPreflistReq struct {
	Bucket           []byte `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Key              []byte `protobuf:"bytes,2,req,name=key" json:"key,omitempty"`
	Type             []byte `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RpbGetBucketKeyPreflistReq) Reset()         { *m = RpbGetBucketKeyPreflistReq{} }
func (m *RpbGetBucketKeyPreflistReq) String() string { return proto.CompactTextString(m) }
func (*RpbGetBucketKeyPreflistReq) ProtoMessage()    {}
func (*RpbGetBucketKeyPreflistReq) Descriptor() ([]byte, []int) {
	return fileDescriptorRiakKv, []int{25}
}

func (m *RpbGetBucketKeyPreflistReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *RpbGetBucketKeyPreflistReq) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RpbGetBucketKeyPreflistReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

// Get bucket-key preflist response
type RpbGetBucketKeyPreflistResp struct {
	Preflist         []*RpbBucketKeyPreflistItem `protobuf:"bytes,1,rep,name=preflist" json:"preflist,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *RpbGetBucketKeyPreflistResp) Reset()         { *m = RpbGetBucketKeyPreflistResp{} }
func (m *RpbGetBucketKeyPreflistResp) String() string { return proto.CompactTextString(m) }
func (*RpbGetBucketKeyPreflistResp) ProtoMessage()    {}
func (*RpbGetBucketKeyPreflistResp) Descriptor() ([]byte, []int) {
	return fileDescriptorRiakKv, []int{26}
}

func (m *RpbGetBucketKeyPreflistResp) GetPreflist() []*RpbBucketKeyPreflistItem {
	if m != nil {
		return m.Preflist
	}
	return nil
}

// Preflist item
type RpbBucketKeyPreflistItem struct {
	Partition        *int64 `protobuf:"varint,1,req,name=partition" json:"partition,omitempty"`
	Node             []byte `protobuf:"bytes,2,req,name=node" json:"node,omitempty"`
	Primary          *bool  `protobuf:"varint,3,req,name=primary" json:"primary,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RpbBucketKeyPreflistItem) Reset()                    { *m = RpbBucketKeyPreflistItem{} }
func (m *RpbBucketKeyPreflistItem) String() string            { return proto.CompactTextString(m) }
func (*RpbBucketKeyPreflistItem) ProtoMessage()               {}
func (*RpbBucketKeyPreflistItem) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{27} }

func (m *RpbBucketKeyPreflistItem) GetPartition() int64 {
	if m != nil && m.Partition != nil {
		return *m.Partition
	}
	return 0
}

func (m *RpbBucketKeyPreflistItem) GetNode() []byte {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *RpbBucketKeyPreflistItem) GetPrimary() bool {
	if m != nil && m.Primary != nil {
		return *m.Primary
	}
	return false
}

// Request a segmented coverage plan for the specified bucket
type RpbCoverageReq struct {
	Type             []byte   `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Bucket           []byte   `protobuf:"bytes,2,req,name=bucket" json:"bucket,omitempty"`
	MinPartitions    *uint32  `protobuf:"varint,3,opt,name=min_partitions" json:"min_partitions,omitempty"`
	ReplaceCover     []byte   `protobuf:"bytes,4,opt,name=replace_cover" json:"replace_cover,omitempty"`
	UnavailableCover [][]byte `protobuf:"bytes,5,rep,name=unavailable_cover" json:"unavailable_cover,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *RpbCoverageReq) Reset()                    { *m = RpbCoverageReq{} }
func (m *RpbCoverageReq) String() string            { return proto.CompactTextString(m) }
func (*RpbCoverageReq) ProtoMessage()               {}
func (*RpbCoverageReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{28} }

func (m *RpbCoverageReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *RpbCoverageReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *RpbCoverageReq) GetMinPartitions() uint32 {
	if m != nil && m.MinPartitions != nil {
		return *m.MinPartitions
	}
	return 0
}

func (m *RpbCoverageReq) GetReplaceCover() []byte {
	if m != nil {
		return m.ReplaceCover
	}
	return nil
}

func (m *RpbCoverageReq) GetUnavailableCover() [][]byte {
	if m != nil {
		return m.UnavailableCover
	}
	return nil
}

// Segmented coverage plan response
type RpbCoverageResp struct {
	Entries          []*RpbCoverageEntry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *RpbCoverageResp) Reset()                    { *m = RpbCoverageResp{} }
func (m *RpbCoverageResp) String() string            { return proto.CompactTextString(m) }
func (*RpbCoverageResp) ProtoMessage()               {}
func (*RpbCoverageResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{29} }

func (m *RpbCoverageResp) GetEntries() []*RpbCoverageEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Segment of a coverage plan
type RpbCoverageEntry struct {
	Ip               []byte  `protobuf:"bytes,1,req,name=ip" json:"ip,omitempty"`
	Port             *uint32 `protobuf:"varint,2,req,name=port" json:"port,omitempty"`
	KeyspaceDesc     []byte  `protobuf:"bytes,3,opt,name=keyspace_desc" json:"keyspace_desc,omitempty"`
	CoverContext     []byte  `protobuf:"bytes,4,req,name=cover_context" json:"cover_context,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RpbCoverageEntry) Reset()                    { *m = RpbCoverageEntry{} }
func (m *RpbCoverageEntry) String() string            { return proto.CompactTextString(m) }
func (*RpbCoverageEntry) ProtoMessage()               {}
func (*RpbCoverageEntry) Descriptor() ([]byte, []int) { return fileDescriptorRiakKv, []int{30} }

func (m *RpbCoverageEntry) GetIp() []byte {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *RpbCoverageEntry) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *RpbCoverageEntry) GetKeyspaceDesc() []byte {
	if m != nil {
		return m.KeyspaceDesc
	}
	return nil
}

func (m *RpbCoverageEntry) GetCoverContext() []byte {
	if m != nil {
		return m.CoverContext
	}
	return nil
}

func init() {
	proto.RegisterType((*RpbGetClientIdResp)(nil), "RpbGetClientIdResp")
	proto.RegisterType((*RpbSetClientIdReq)(nil), "RpbSetClientIdReq")
	proto.RegisterType((*RpbGetReq)(nil), "RpbGetReq")
	proto.RegisterType((*RpbGetResp)(nil), "RpbGetResp")
	proto.RegisterType((*RpbPutReq)(nil), "RpbPutReq")
	proto.RegisterType((*RpbPutResp)(nil), "RpbPutResp")
	proto.RegisterType((*RpbDelReq)(nil), "RpbDelReq")
	proto.RegisterType((*RpbListBucketsReq)(nil), "RpbListBucketsReq")
	proto.RegisterType((*RpbListBucketsResp)(nil), "RpbListBucketsResp")
	proto.RegisterType((*RpbListKeysReq)(nil), "RpbListKeysReq")
	proto.RegisterType((*RpbListKeysResp)(nil), "RpbListKeysResp")
	proto.RegisterType((*RpbMapRedReq)(nil), "RpbMapRedReq")
	proto.RegisterType((*RpbMapRedResp)(nil), "RpbMapRedResp")
	proto.RegisterType((*RpbIndexReq)(nil), "RpbIndexReq")
	proto.RegisterType((*RpbIndexResp)(nil), "RpbIndexResp")
	proto.RegisterType((*RpbIndexBodyResp)(nil), "RpbIndexBodyResp")
	proto.RegisterType((*RpbCSBucketReq)(nil), "RpbCSBucketReq")
	proto.RegisterType((*RpbCSBucketResp)(nil), "RpbCSBucketResp")
	proto.RegisterType((*RpbIndexObject)(nil), "RpbIndexObject")
	proto.RegisterType((*RpbContent)(nil), "RpbContent")
	proto.RegisterType((*RpbLink)(nil), "RpbLink")
	proto.RegisterType((*RpbCounterUpdateReq)(nil), "RpbCounterUpdateReq")
	proto.RegisterType((*RpbCounterUpdateResp)(nil), "RpbCounterUpdateResp")
	proto.RegisterType((*RpbCounterGetReq)(nil), "RpbCounterGetReq")
	proto.RegisterType((*RpbCounterGetResp)(nil), "RpbCounterGetResp")
	proto.RegisterType((*RpbGetBucketKeyPreflistReq)(nil), "RpbGetBucketKeyPreflistReq")
	proto.RegisterType((*RpbGetBucketKeyPreflistResp)(nil), "RpbGetBucketKeyPreflistResp")
	proto.RegisterType((*RpbBucketKeyPreflistItem)(nil), "RpbBucketKeyPreflistItem")
	proto.RegisterType((*RpbCoverageReq)(nil), "RpbCoverageReq")
	proto.RegisterType((*RpbCoverageResp)(nil), "RpbCoverageResp")
	proto.RegisterType((*RpbCoverageEntry)(nil), "RpbCoverageEntry")
	proto.RegisterEnum("RpbIndexReq_IndexQueryType", RpbIndexReq_IndexQueryType_name, RpbIndexReq_IndexQueryType_value)
}
func (m *RpbGetClientIdResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbGetClientIdResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.ClientId)))
		i += copy(data[i:], m.ClientId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbSetClientIdReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbSetClientIdReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.ClientId)))
		i += copy(data[i:], m.ClientId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbGetReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbGetReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.R != nil {
		data[i] = 0x18
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.R))
	}
	if m.Pr != nil {
		data[i] = 0x20
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Pr))
	}
	if m.BasicQuorum != nil {
		data[i] = 0x28
		i++
		if *m.BasicQuorum {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NotfoundOk != nil {
		data[i] = 0x30
		i++
		if *m.NotfoundOk {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.IfModified != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.IfModified)))
		i += copy(data[i:], m.IfModified)
	}
	if m.Head != nil {
		data[i] = 0x40
		i++
		if *m.Head {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Deletedvclock != nil {
		data[i] = 0x48
		i++
		if *m.Deletedvclock {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Timeout != nil {
		data[i] = 0x50
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		data[i] = 0x58
		i++
		if *m.SloppyQuorum {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NVal != nil {
		data[i] = 0x60
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.NVal))
	}
	if m.Type != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbGetResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbGetResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		for _, msg := range m.Content {
			data[i] = 0xa
			i++
			i = encodeVarintRiakKv(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Vclock != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Vclock)))
		i += copy(data[i:], m.Vclock)
	}
	if m.Unchanged != nil {
		data[i] = 0x18
		i++
		if *m.Unchanged {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbPutReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbPutReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Key != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Vclock != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Vclock)))
		i += copy(data[i:], m.Vclock)
	}
	if m.Content == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x22
		i++
		i = encodeVarintRiakKv(data, i, uint64(m.Content.Size()))
		n1, err := m.Content.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.W != nil {
		data[i] = 0x28
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.W))
	}
	if m.Dw != nil {
		data[i] = 0x30
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Dw))
	}
	if m.ReturnBody != nil {
		data[i] = 0x38
		i++
		if *m.ReturnBody {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Pw != nil {
		data[i] = 0x40
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Pw))
	}
	if m.IfNotModified != nil {
		data[i] = 0x48
		i++
		if *m.IfNotModified {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.IfNoneMatch != nil {
		data[i] = 0x50
		i++
		if *m.IfNoneMatch {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ReturnHead != nil {
		data[i] = 0x58
		i++
		if *m.ReturnHead {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Timeout != nil {
		data[i] = 0x60
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Timeout))
	}
	if m.Asis != nil {
		data[i] = 0x68
		i++
		if *m.Asis {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.SloppyQuorum != nil {
		data[i] = 0x70
		i++
		if *m.SloppyQuorum {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NVal != nil {
		data[i] = 0x78
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.NVal))
	}
	if m.Type != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbPutResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbPutResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		for _, msg := range m.Content {
			data[i] = 0xa
			i++
			i = encodeVarintRiakKv(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Vclock != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Vclock)))
		i += copy(data[i:], m.Vclock)
	}
	if m.Key != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbDelReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbDelReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Rw != nil {
		data[i] = 0x18
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Rw))
	}
	if m.Vclock != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Vclock)))
		i += copy(data[i:], m.Vclock)
	}
	if m.R != nil {
		data[i] = 0x28
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.R))
	}
	if m.W != nil {
		data[i] = 0x30
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.W))
	}
	if m.Pr != nil {
		data[i] = 0x38
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Pr))
	}
	if m.Pw != nil {
		data[i] = 0x40
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Pw))
	}
	if m.Dw != nil {
		data[i] = 0x48
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Dw))
	}
	if m.Timeout != nil {
		data[i] = 0x50
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		data[i] = 0x58
		i++
		if *m.SloppyQuorum {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NVal != nil {
		data[i] = 0x60
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.NVal))
	}
	if m.Type != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbListBucketsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbListBucketsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timeout != nil {
		data[i] = 0x8
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Timeout))
	}
	if m.Stream != nil {
		data[i] = 0x10
		i++
		if *m.Stream {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Type != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbListBucketsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbListBucketsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Buckets) > 0 {
		for _, b := range m.Buckets {
			data[i] = 0xa
			i++
			i = encodeVarintRiakKv(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if m.Done != nil {
		data[i] = 0x10
		i++
		if *m.Done {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbListKeysReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbListKeysReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Timeout != nil {
		data[i] = 0x10
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Timeout))
	}
	if m.Type != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbListKeysResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbListKeysResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			data[i] = 0xa
			i++
			i = encodeVarintRiakKv(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if m.Done != nil {
		data[i] = 0x10
		i++
		if *m.Done {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbMapRedReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbMapRedReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Request == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Request)))
		i += copy(data[i:], m.Request)
	}
	if m.ContentType == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.ContentType)))
		i += copy(data[i:], m.ContentType)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbMapRedResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbMapRedResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Phase != nil {
		data[i] = 0x8
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Phase))
	}
	if m.Response != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Response)))
		i += copy(data[i:], m.Response)
	}
	if m.Done != nil {
		data[i] = 0x18
		i++
		if *m.Done {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbIndexReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbIndexReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Index == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Index)))
		i += copy(data[i:], m.Index)
	}
	if m.Qtype == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x18
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Qtype))
	}
	if m.Key != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.RangeMin != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.RangeMin)))
		i += copy(data[i:], m.RangeMin)
	}
	if m.RangeMax != nil {
		data[i] = 0x32
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.RangeMax)))
		i += copy(data[i:], m.RangeMax)
	}
	if m.ReturnTerms != nil {
		data[i] = 0x38
		i++
		if *m.ReturnTerms {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Stream != nil {
		data[i] = 0x40
		i++
		if *m.Stream {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.MaxResults != nil {
		data[i] = 0x48
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.MaxResults))
	}
	if m.Continuation != nil {
		data[i] = 0x52
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Continuation)))
		i += copy(data[i:], m.Continuation)
	}
	if m.Timeout != nil {
		data[i] = 0x58
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Timeout))
	}
	if m.Type != nil {
		data[i] = 0x62
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.TermRegex != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.TermRegex)))
		i += copy(data[i:], m.TermRegex)
	}
	if m.PaginationSort != nil {
		data[i] = 0x70
		i++
		if *m.PaginationSort {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.CoverContext != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.CoverContext)))
		i += copy(data[i:], m.CoverContext)
	}
	if m.ReturnBody != nil {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		if *m.ReturnBody {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbIndexResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbIndexResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			data[i] = 0xa
			i++
			i = encodeVarintRiakKv(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			data[i] = 0x12
			i++
			i = encodeVarintRiakKv(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Continuation != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Continuation)))
		i += copy(data[i:], m.Continuation)
	}
	if m.Done != nil {
		data[i] = 0x20
		i++
		if *m.Done {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbIndexBodyResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbIndexBodyResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, msg := range m.Objects {
			data[i] = 0xa
			i++
			i = encodeVarintRiakKv(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Continuation != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Continuation)))
		i += copy(data[i:], m.Continuation)
	}
	if m.Done != nil {
		data[i] = 0x18
		i++
		if *m.Done {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbCSBucketReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbCSBucketReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.StartKey == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.StartKey)))
		i += copy(data[i:], m.StartKey)
	}
	if m.EndKey != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.EndKey)))
		i += copy(data[i:], m.EndKey)
	}
	if m.StartIncl != nil {
		data[i] = 0x20
		i++
		if *m.StartIncl {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.EndIncl != nil {
		data[i] = 0x28
		i++
		if *m.EndIncl {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Continuation != nil {
		data[i] = 0x32
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Continuation)))
		i += copy(data[i:], m.Continuation)
	}
	if m.MaxResults != nil {
		data[i] = 0x38
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.MaxResults))
	}
	if m.Timeout != nil {
		data[i] = 0x40
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Timeout))
	}
	if m.Type != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.CoverContext != nil {
		data[i] = 0x52
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.CoverContext)))
		i += copy(data[i:], m.CoverContext)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbCSBucketResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbCSBucketResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, msg := range m.Objects {
			data[i] = 0xa
			i++
			i = encodeVarintRiakKv(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Continuation != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Continuation)))
		i += copy(data[i:], m.Continuation)
	}
	if m.Done != nil {
		data[i] = 0x18
		i++
		if *m.Done {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbIndexObject) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbIndexObject) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Object == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(m.Object.Size()))
		n2, err := m.Object.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbContent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbContent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	if m.ContentType != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.ContentType)))
		i += copy(data[i:], m.ContentType)
	}
	if m.Charset != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Charset)))
		i += copy(data[i:], m.Charset)
	}
	if m.ContentEncoding != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.ContentEncoding)))
		i += copy(data[i:], m.ContentEncoding)
	}
	if m.Vtag != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Vtag)))
		i += copy(data[i:], m.Vtag)
	}
	if len(m.Links) > 0 {
		for _, msg := range m.Links {
			data[i] = 0x32
			i++
			i = encodeVarintRiakKv(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LastMod != nil {
		data[i] = 0x38
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.LastMod))
	}
	if m.LastModUsecs != nil {
		data[i] = 0x40
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.LastModUsecs))
	}
	if len(m.Usermeta) > 0 {
		for _, msg := range m.Usermeta {
			data[i] = 0x4a
			i++
			i = encodeVarintRiakKv(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Indexes) > 0 {
		for _, msg := range m.Indexes {
			data[i] = 0x52
			i++
			i = encodeVarintRiakKv(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Deleted != nil {
		data[i] = 0x58
		i++
		if *m.Deleted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbLink) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbLink) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Key != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Tag != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Tag)))
		i += copy(data[i:], m.Tag)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbCounterUpdateReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbCounterUpdateReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Amount == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x18
		i++
		i = encodeVarintRiakKv(data, i, uint64((uint64(*m.Amount)<<1)^uint64((*m.Amount>>63))))
	}
	if m.W != nil {
		data[i] = 0x20
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.W))
	}
	if m.Dw != nil {
		data[i] = 0x28
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Dw))
	}
	if m.Pw != nil {
		data[i] = 0x30
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Pw))
	}
	if m.Returnvalue != nil {
		data[i] = 0x38
		i++
		if *m.Returnvalue {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbCounterUpdateResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbCounterUpdateResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		data[i] = 0x8
		i++
		i = encodeVarintRiakKv(data, i, uint64((uint64(*m.Value)<<1)^uint64((*m.Value>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbCounterGetReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbCounterGetReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.R != nil {
		data[i] = 0x18
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.R))
	}
	if m.Pr != nil {
		data[i] = 0x20
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Pr))
	}
	if m.BasicQuorum != nil {
		data[i] = 0x28
		i++
		if *m.BasicQuorum {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NotfoundOk != nil {
		data[i] = 0x30
		i++
		if *m.NotfoundOk {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbCounterGetResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbCounterGetResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		data[i] = 0x8
		i++
		i = encodeVarintRiakKv(data, i, uint64((uint64(*m.Value)<<1)^uint64((*m.Value>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbGetBucketKeyPreflistReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbGetBucketKeyPreflistReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Type != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbGetBucketKeyPreflistResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbGetBucketKeyPreflistResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Preflist) > 0 {
		for _, msg := range m.Preflist {
			data[i] = 0xa
			i++
			i = encodeVarintRiakKv(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbBucketKeyPreflistItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbBucketKeyPreflistItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Partition == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x8
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Partition))
	}
	if m.Node == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Node)))
		i += copy(data[i:], m.Node)
	}
	if m.Primary == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x18
		i++
		if *m.Primary {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbCoverageReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbCoverageReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.MinPartitions != nil {
		data[i] = 0x18
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.MinPartitions))
	}
	if m.ReplaceCover != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.ReplaceCover)))
		i += copy(data[i:], m.ReplaceCover)
	}
	if len(m.UnavailableCover) > 0 {
		for _, b := range m.UnavailableCover {
			data[i] = 0x2a
			i++
			i = encodeVarintRiakKv(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbCoverageResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbCoverageResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			data[i] = 0xa
			i++
			i = encodeVarintRiakKv(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RpbCoverageEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RpbCoverageEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ip == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.Ip)))
		i += copy(data[i:], m.Ip)
	}
	if m.Port == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x10
		i++
		i = encodeVarintRiakKv(data, i, uint64(*m.Port))
	}
	if m.KeyspaceDesc != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.KeyspaceDesc)))
		i += copy(data[i:], m.KeyspaceDesc)
	}
	if m.CoverContext == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x22
		i++
		i = encodeVarintRiakKv(data, i, uint64(len(m.CoverContext)))
		i += copy(data[i:], m.CoverContext)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64RiakKv(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32RiakKv(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRiakKv(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *RpbGetClientIdResp) Size() (n int) {
	var l int
	_ = l
	if m.ClientId != nil {
		l = len(m.ClientId)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbSetClientIdReq) Size() (n int) {
	var l int
	_ = l
	if m.ClientId != nil {
		l = len(m.ClientId)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbGetReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.R != nil {
		n += 1 + sovRiakKv(uint64(*m.R))
	}
	if m.Pr != nil {
		n += 1 + sovRiakKv(uint64(*m.Pr))
	}
	if m.BasicQuorum != nil {
		n += 2
	}
	if m.NotfoundOk != nil {
		n += 2
	}
	if m.IfModified != nil {
		l = len(m.IfModified)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Head != nil {
		n += 2
	}
	if m.Deletedvclock != nil {
		n += 2
	}
	if m.Timeout != nil {
		n += 1 + sovRiakKv(uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		n += 2
	}
	if m.NVal != nil {
		n += 1 + sovRiakKv(uint64(*m.NVal))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbGetResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Content) > 0 {
		for _, e := range m.Content {
			l = e.Size()
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.Vclock != nil {
		l = len(m.Vclock)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Unchanged != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbPutReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Vclock != nil {
		l = len(m.Vclock)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Content != nil {
		l = m.Content.Size()
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.W != nil {
		n += 1 + sovRiakKv(uint64(*m.W))
	}
	if m.Dw != nil {
		n += 1 + sovRiakKv(uint64(*m.Dw))
	}
	if m.ReturnBody != nil {
		n += 2
	}
	if m.Pw != nil {
		n += 1 + sovRiakKv(uint64(*m.Pw))
	}
	if m.IfNotModified != nil {
		n += 2
	}
	if m.IfNoneMatch != nil {
		n += 2
	}
	if m.ReturnHead != nil {
		n += 2
	}
	if m.Timeout != nil {
		n += 1 + sovRiakKv(uint64(*m.Timeout))
	}
	if m.Asis != nil {
		n += 2
	}
	if m.SloppyQuorum != nil {
		n += 2
	}
	if m.NVal != nil {
		n += 1 + sovRiakKv(uint64(*m.NVal))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 2 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbPutResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Content) > 0 {
		for _, e := range m.Content {
			l = e.Size()
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.Vclock != nil {
		l = len(m.Vclock)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbDelReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Rw != nil {
		n += 1 + sovRiakKv(uint64(*m.Rw))
	}
	if m.Vclock != nil {
		l = len(m.Vclock)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.R != nil {
		n += 1 + sovRiakKv(uint64(*m.R))
	}
	if m.W != nil {
		n += 1 + sovRiakKv(uint64(*m.W))
	}
	if m.Pr != nil {
		n += 1 + sovRiakKv(uint64(*m.Pr))
	}
	if m.Pw != nil {
		n += 1 + sovRiakKv(uint64(*m.Pw))
	}
	if m.Dw != nil {
		n += 1 + sovRiakKv(uint64(*m.Dw))
	}
	if m.Timeout != nil {
		n += 1 + sovRiakKv(uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		n += 2
	}
	if m.NVal != nil {
		n += 1 + sovRiakKv(uint64(*m.NVal))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbListBucketsReq) Size() (n int) {
	var l int
	_ = l
	if m.Timeout != nil {
		n += 1 + sovRiakKv(uint64(*m.Timeout))
	}
	if m.Stream != nil {
		n += 2
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbListBucketsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Buckets) > 0 {
		for _, b := range m.Buckets {
			l = len(b)
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.Done != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbListKeysReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Timeout != nil {
		n += 1 + sovRiakKv(uint64(*m.Timeout))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbListKeysResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.Done != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbMapRedReq) Size() (n int) {
	var l int
	_ = l
	if m.Request != nil {
		l = len(m.Request)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.ContentType != nil {
		l = len(m.ContentType)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbMapRedResp) Size() (n int) {
	var l int
	_ = l
	if m.Phase != nil {
		n += 1 + sovRiakKv(uint64(*m.Phase))
	}
	if m.Response != nil {
		l = len(m.Response)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Done != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbIndexReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Index != nil {
		l = len(m.Index)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Qtype != nil {
		n += 1 + sovRiakKv(uint64(*m.Qtype))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.RangeMin != nil {
		l = len(m.RangeMin)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.RangeMax != nil {
		l = len(m.RangeMax)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.ReturnTerms != nil {
		n += 2
	}
	if m.Stream != nil {
		n += 2
	}
	if m.MaxResults != nil {
		n += 1 + sovRiakKv(uint64(*m.MaxResults))
	}
	if m.Continuation != nil {
		l = len(m.Continuation)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Timeout != nil {
		n += 1 + sovRiakKv(uint64(*m.Timeout))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.TermRegex != nil {
		l = len(m.TermRegex)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.PaginationSort != nil {
		n += 2
	}
	if m.CoverContext != nil {
		l = len(m.CoverContext)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.ReturnBody != nil {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbIndexResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.Continuation != nil {
		l = len(m.Continuation)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Done != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbIndexBodyResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.Continuation != nil {
		l = len(m.Continuation)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Done != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbCSBucketReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.StartKey != nil {
		l = len(m.StartKey)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.EndKey != nil {
		l = len(m.EndKey)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.StartIncl != nil {
		n += 2
	}
	if m.EndIncl != nil {
		n += 2
	}
	if m.Continuation != nil {
		l = len(m.Continuation)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.MaxResults != nil {
		n += 1 + sovRiakKv(uint64(*m.MaxResults))
	}
	if m.Timeout != nil {
		n += 1 + sovRiakKv(uint64(*m.Timeout))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.CoverContext != nil {
		l = len(m.CoverContext)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbCSBucketResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.Continuation != nil {
		l = len(m.Continuation)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Done != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbIndexObject) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbContent) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.ContentType != nil {
		l = len(m.ContentType)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Charset != nil {
		l = len(m.Charset)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.ContentEncoding != nil {
		l = len(m.ContentEncoding)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Vtag != nil {
		l = len(m.Vtag)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.LastMod != nil {
		n += 1 + sovRiakKv(uint64(*m.LastMod))
	}
	if m.LastModUsecs != nil {
		n += 1 + sovRiakKv(uint64(*m.LastModUsecs))
	}
	if len(m.Usermeta) > 0 {
		for _, e := range m.Usermeta {
			l = e.Size()
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.Deleted != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbLink) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Tag != nil {
		l = len(m.Tag)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbCounterUpdateReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Amount != nil {
		n += 1 + sozRiakKv(uint64(*m.Amount))
	}
	if m.W != nil {
		n += 1 + sovRiakKv(uint64(*m.W))
	}
	if m.Dw != nil {
		n += 1 + sovRiakKv(uint64(*m.Dw))
	}
	if m.Pw != nil {
		n += 1 + sovRiakKv(uint64(*m.Pw))
	}
	if m.Returnvalue != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbCounterUpdateResp) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += 1 + sozRiakKv(uint64(*m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbCounterGetReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.R != nil {
		n += 1 + sovRiakKv(uint64(*m.R))
	}
	if m.Pr != nil {
		n += 1 + sovRiakKv(uint64(*m.Pr))
	}
	if m.BasicQuorum != nil {
		n += 2
	}
	if m.NotfoundOk != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbCounterGetResp) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += 1 + sozRiakKv(uint64(*m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbGetBucketKeyPreflistReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbGetBucketKeyPreflistResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Preflist) > 0 {
		for _, e := range m.Preflist {
			l = e.Size()
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbBucketKeyPreflistItem) Size() (n int) {
	var l int
	_ = l
	if m.Partition != nil {
		n += 1 + sovRiakKv(uint64(*m.Partition))
	}
	if m.Node != nil {
		l = len(m.Node)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Primary != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbCoverageReq) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.MinPartitions != nil {
		n += 1 + sovRiakKv(uint64(*m.MinPartitions))
	}
	if m.ReplaceCover != nil {
		l = len(m.ReplaceCover)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if len(m.UnavailableCover) > 0 {
		for _, b := range m.UnavailableCover {
			l = len(b)
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbCoverageResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRiakKv(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpbCoverageEntry) Size() (n int) {
	var l int
	_ = l
	if m.Ip != nil {
		l = len(m.Ip)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.Port != nil {
		n += 1 + sovRiakKv(uint64(*m.Port))
	}
	if m.KeyspaceDesc != nil {
		l = len(m.KeyspaceDesc)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.CoverContext != nil {
		l = len(m.CoverContext)
		n += 1 + l + sovRiakKv(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRiakKv(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRiakKv(x uint64) (n int) {
	return sovRiakKv(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RpbGetClientIdResp) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbGetClientIdResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbGetClientIdResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = append(m.ClientId[:0], data[iNdEx:postIndex]...)
			if m.ClientId == nil {
				m.ClientId = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbSetClientIdReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbSetClientIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbSetClientIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = append(m.ClientId[:0], data[iNdEx:postIndex]...)
			if m.ClientId == nil {
				m.ClientId = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbGetReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.R = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pr", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pr = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BasicQuorum = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotfoundOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NotfoundOk = &b
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfModified", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IfModified = append(m.IfModified[:0], data[iNdEx:postIndex]...)
			if m.IfModified == nil {
				m.IfModified = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Head = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deletedvclock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deletedvclock = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SloppyQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SloppyQuorum = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NVal", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NVal = &v
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], data[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbGetResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbGetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbGetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content, &RpbContent{})
			if err := m.Content[len(m.Content)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vclock", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vclock = append(m.Vclock[:0], data[iNdEx:postIndex]...)
			if m.Vclock == nil {
				m.Vclock = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unchanged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Unchanged = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbPutReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbPutReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbPutReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vclock", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vclock = append(m.Vclock[:0], data[iNdEx:postIndex]...)
			if m.Vclock == nil {
				m.Vclock = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &RpbContent{}
			}
			if err := m.Content.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.W = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dw", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dw = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnBody", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReturnBody = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pw", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pw = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotModified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IfNotModified = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNoneMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IfNoneMatch = &b
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnHead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReturnHead = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Asis = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SloppyQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SloppyQuorum = &b
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NVal", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NVal = &v
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], data[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbPutResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbPutResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbPutResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content, &RpbContent{})
			if err := m.Content[len(m.Content)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vclock", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vclock = append(m.Vclock[:0], data[iNdEx:postIndex]...)
			if m.Vclock == nil {
				m.Vclock = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbDelReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbDelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbDelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rw", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rw = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vclock", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vclock = append(m.Vclock[:0], data[iNdEx:postIndex]...)
			if m.Vclock == nil {
				m.Vclock = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.R = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.W = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pr", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pr = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pw", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pw = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dw", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dw = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SloppyQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SloppyQuorum = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NVal", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NVal = &v
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], data[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbListBucketsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbListBucketsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbListBucketsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Stream = &b
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], data[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbListBucketsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbListBucketsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbListBucketsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buckets = append(m.Buckets, make([]byte, postIndex-iNdEx))
			copy(m.Buckets[len(m.Buckets)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Done = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbListKeysReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbListKeysReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbListKeysReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], data[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbListKeysResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbListKeysResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbListKeysResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Done = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbMapRedReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbMapRedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbMapRedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request[:0], data[iNdEx:postIndex]...)
			if m.Request == nil {
				m.Request = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = append(m.ContentType[:0], data[iNdEx:postIndex]...)
			if m.ContentType == nil {
				m.ContentType = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbMapRedResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbMapRedResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbMapRedResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Phase = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response[:0], data[iNdEx:postIndex]...)
			if m.Response == nil {
				m.Response = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Done = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbIndexReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbIndexReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbIndexReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append(m.Index[:0], data[iNdEx:postIndex]...)
			if m.Index == nil {
				m.Index = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qtype", wireType)
			}
			var v RpbIndexReq_IndexQueryType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (RpbIndexReq_IndexQueryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Qtype = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeMin = append(m.RangeMin[:0], data[iNdEx:postIndex]...)
			if m.RangeMin == nil {
				m.RangeMin = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMax", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeMax = append(m.RangeMax[:0], data[iNdEx:postIndex]...)
			if m.RangeMax == nil {
				m.RangeMax = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnTerms", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReturnTerms = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Stream = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxResults = &v
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Continuation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Continuation = append(m.Continuation[:0], data[iNdEx:postIndex]...)
			if m.Continuation == nil {
				m.Continuation = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], data[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TermRegex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TermRegex = append(m.TermRegex[:0], data[iNdEx:postIndex]...)
			if m.TermRegex == nil {
				m.TermRegex = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaginationSort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PaginationSort = &b
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverContext", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverContext = append(m.CoverContext[:0], data[iNdEx:postIndex]...)
			if m.CoverContext == nil {
				m.CoverContext = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnBody", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReturnBody = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbIndexResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbIndexResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbIndexResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &riak.RpbPair{})
			if err := m.Results[len(m.Results)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Continuation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Continuation = append(m.Continuation[:0], data[iNdEx:postIndex]...)
			if m.Continuation == nil {
				m.Continuation = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Done = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbIndexBodyResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbIndexBodyResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbIndexBodyResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &RpbIndexObject{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Continuation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Continuation = append(m.Continuation[:0], data[iNdEx:postIndex]...)
			if m.Continuation == nil {
				m.Continuation = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Done = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbCSBucketReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbCSBucketReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbCSBucketReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], data[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], data[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIncl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.StartIncl = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndIncl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.EndIncl = &b
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Continuation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Continuation = append(m.Continuation[:0], data[iNdEx:postIndex]...)
			if m.Continuation == nil {
				m.Continuation = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxResults = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], data[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverContext", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverContext = append(m.CoverContext[:0], data[iNdEx:postIndex]...)
			if m.CoverContext == nil {
				m.CoverContext = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbCSBucketResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbCSBucketResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbCSBucketResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &RpbIndexObject{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Continuation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Continuation = append(m.Continuation[:0], data[iNdEx:postIndex]...)
			if m.Continuation == nil {
				m.Continuation = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Done = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbIndexObject) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbIndexObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbIndexObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &RpbGetResp{}
			}
			if err := m.Object.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbContent) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], data[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = append(m.ContentType[:0], data[iNdEx:postIndex]...)
			if m.ContentType == nil {
				m.ContentType = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Charset = append(m.Charset[:0], data[iNdEx:postIndex]...)
			if m.Charset == nil {
				m.Charset = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentEncoding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentEncoding = append(m.ContentEncoding[:0], data[iNdEx:postIndex]...)
			if m.ContentEncoding == nil {
				m.ContentEncoding = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vtag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vtag = append(m.Vtag[:0], data[iNdEx:postIndex]...)
			if m.Vtag == nil {
				m.Vtag = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &RpbLink{})
			if err := m.Links[len(m.Links)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMod", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastMod = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModUsecs", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastModUsecs = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usermeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usermeta = append(m.Usermeta, &riak.RpbPair{})
			if err := m.Usermeta[len(m.Usermeta)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, &riak.RpbPair{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deleted = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbLink) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = append(m.Tag[:0], data[iNdEx:postIndex]...)
			if m.Tag == nil {
				m.Tag = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbCounterUpdateReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbCounterUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbCounterUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Amount = &v2
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.W = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dw", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dw = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pw", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pw = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Returnvalue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Returnvalue = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbCounterUpdateResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbCounterUpdateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbCounterUpdateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Value = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbCounterGetReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbCounterGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbCounterGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.R = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pr", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pr = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BasicQuorum = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotfoundOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NotfoundOk = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbCounterGetResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbCounterGetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbCounterGetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Value = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbGetBucketKeyPreflistReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbGetBucketKeyPreflistReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbGetBucketKeyPreflistReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], data[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbGetBucketKeyPreflistResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbGetBucketKeyPreflistResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbGetBucketKeyPreflistResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preflist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Preflist = append(m.Preflist, &RpbBucketKeyPreflistItem{})
			if err := m.Preflist[len(m.Preflist)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbBucketKeyPreflistItem) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbBucketKeyPreflistItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbBucketKeyPreflistItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Partition = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = append(m.Node[:0], data[iNdEx:postIndex]...)
			if m.Node == nil {
				m.Node = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Primary = &b
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbCoverageReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbCoverageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbCoverageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], data[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPartitions", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinPartitions = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceCover", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplaceCover = append(m.ReplaceCover[:0], data[iNdEx:postIndex]...)
			if m.ReplaceCover == nil {
				m.ReplaceCover = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnavailableCover", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnavailableCover = append(m.UnavailableCover, make([]byte, postIndex-iNdEx))
			copy(m.UnavailableCover[len(m.UnavailableCover)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbCoverageResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbCoverageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbCoverageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &RpbCoverageEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpbCoverageEntry) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpbCoverageEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpbCoverageEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = append(m.Ip[:0], data[iNdEx:postIndex]...)
			if m.Ip == nil {
				m.Ip = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceDesc", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceDesc = append(m.KeyspaceDesc[:0], data[iNdEx:postIndex]...)
			if m.KeyspaceDesc == nil {
				m.KeyspaceDesc = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverContext", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverContext = append(m.CoverContext[:0], data[iNdEx:postIndex]...)
			if m.CoverContext == nil {
				m.CoverContext = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipRiakKv(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRiakKv(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRiakKv
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRiakKv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRiakKv
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRiakKv
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRiakKv(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRiakKv = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRiakKv   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("riak_kv.proto", fileDescriptorRiakKv) }

var fileDescriptorRiakKv = []byte{
	// 1369 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x57, 0xcd, 0x8e, 0x1b, 0x45,
	0x10, 0xce, 0x78, 0xed, 0xf5, 0xb8, 0x6d, 0xef, 0x7a, 0x9d, 0x40, 0x26, 0x09, 0x8a, 0xa2, 0x41,
	0xc0, 0x0a, 0x84, 0x0f, 0x89, 0xb8, 0xe4, 0x00, 0xd2, 0x06, 0x14, 0x85, 0x24, 0x62, 0xd9, 0x80,
	0x40, 0x70, 0x18, 0xb5, 0x67, 0xda, 0xde, 0xc1, 0xf3, 0xe7, 0xee, 0x1e, 0xef, 0x9a, 0x27, 0xe1,
	0x09, 0x78, 0x11, 0x2e, 0x1c, 0x39, 0x72, 0x44, 0x70, 0xe2, 0x01, 0x38, 0x70, 0xa3, 0xba, 0xba,
	0xdb, 0x9e, 0xb1, 0x1d, 0x56, 0x48, 0x11, 0x87, 0x95, 0xdc, 0xdd, 0xd5, 0x55, 0xd5, 0x5f, 0x7d,
	0xf5, 0xd5, 0x2c, 0xe9, 0xf3, 0x98, 0xce, 0x82, 0xd9, 0x62, 0x54, 0xf0, 0x5c, 0xe6, 0xb7, 0x89,
	0x5a, 0xea, 0xdf, 0xfe, 0x3b, 0x64, 0x78, 0x56, 0x8c, 0x1f, 0x33, 0xf9, 0x28, 0x89, 0x59, 0x26,
	0x9f, 0x44, 0x67, 0x4c, 0x14, 0xc3, 0x23, 0xd2, 0x09, 0x71, 0x1d, 0xc4, 0x91, 0xe7, 0xdc, 0x6b,
	0x1c, 0xf7, 0xfc, 0xb7, 0xc9, 0x11, 0x18, 0xbe, 0xa8, 0x1a, 0xce, 0x77, 0xd9, 0xfd, 0xe9, 0x90,
	0x8e, 0xf6, 0xa8, 0x0c, 0x0e, 0xc8, 0xfe, 0xb8, 0x0c, 0x67, 0x4c, 0xea, 0xd3, 0x61, 0x97, 0xec,
	0xcd, 0xd8, 0xd2, 0x6b, 0xe0, 0xa2, 0x43, 0x1c, 0xee, 0xed, 0xdd, 0x73, 0x8e, 0xfb, 0x43, 0x42,
	0x1a, 0x05, 0xf7, 0x9a, 0xf8, 0xfb, 0x06, 0xe9, 0x8d, 0xa9, 0x88, 0xc3, 0x60, 0x5e, 0xe6, 0xbc,
	0x4c, 0xbd, 0x16, 0xec, 0xba, 0xc3, 0xeb, 0xa4, 0x9b, 0xe5, 0x72, 0x92, 0x97, 0x59, 0x14, 0xe4,
	0x33, 0x6f, 0xdf, 0x6e, 0xc6, 0x93, 0x20, 0xcd, 0xa3, 0x78, 0x12, 0xb3, 0xc8, 0x6b, 0xc3, 0x66,
	0x6f, 0xd8, 0x23, 0xcd, 0x73, 0x46, 0x23, 0xcf, 0x45, 0x93, 0xd7, 0x48, 0x3f, 0x62, 0x09, 0x93,
	0x2c, 0x5a, 0x84, 0x49, 0x1e, 0xce, 0xbc, 0x0e, 0x6e, 0x1f, 0x92, 0xb6, 0x8c, 0x53, 0x96, 0x97,
	0xd2, 0x23, 0x18, 0x15, 0xec, 0x44, 0x92, 0x17, 0xc5, 0xd2, 0x86, 0xed, 0xa2, 0x5d, 0x9f, 0xb4,
	0xb2, 0x60, 0x41, 0x13, 0xaf, 0x87, 0x56, 0xe0, 0x5b, 0x2e, 0x0b, 0xe6, 0xf5, 0x55, 0x24, 0xff,
	0x39, 0x21, 0xf6, 0xa9, 0x00, 0xda, 0x1b, 0xa4, 0x1d, 0xe6, 0x99, 0x04, 0x34, 0xe0, 0xb1, 0x7b,
	0xc7, 0xdd, 0xfb, 0xdd, 0x11, 0x9c, 0x3e, 0xd2, 0x5b, 0x0a, 0x09, 0x93, 0x40, 0x03, 0xb3, 0x04,
	0xe8, 0xca, 0x2c, 0x3c, 0xa7, 0xd9, 0x14, 0x12, 0x57, 0x20, 0xb8, 0xfe, 0x8f, 0x0d, 0x84, 0xee,
	0xb4, 0xfc, 0x77, 0xe8, 0xd4, 0xed, 0xb5, 0xb7, 0x3d, 0x5c, 0x57, 0x62, 0x37, 0xc1, 0x7a, 0x23,
	0x36, 0x00, 0x7d, 0x81, 0x30, 0x22, 0xd0, 0xd1, 0x05, 0xa2, 0xd7, 0x57, 0xe8, 0x71, 0x26, 0x4b,
	0x9e, 0x05, 0xe3, 0x3c, 0x5a, 0x22, 0x7a, 0x2e, 0x56, 0xe2, 0x02, 0xb1, 0xeb, 0x0f, 0x6f, 0x92,
	0x43, 0x80, 0x17, 0x60, 0x5f, 0x43, 0xdc, 0xb1, 0xa0, 0xe2, 0x41, 0xc6, 0x82, 0x94, 0xca, 0xf0,
	0x1c, 0x31, 0x74, 0x2b, 0x0e, 0xb1, 0x00, 0xdd, 0x4d, 0xa4, 0x57, 0x18, 0x42, 0x79, 0x05, 0x62,
	0xe8, 0x6e, 0xe3, 0x7e, 0x50, 0xc7, 0xfd, 0xb0, 0x86, 0xfb, 0x00, 0x71, 0x7f, 0x8c, 0xb8, 0x23,
	0x4e, 0xff, 0x19, 0x77, 0x03, 0x23, 0xc2, 0xe6, 0xff, 0xa4, 0xc9, 0xfa, 0x31, 0x4b, 0xae, 0x24,
	0x2b, 0xe0, 0xc2, 0x2f, 0x0c, 0x5b, 0xd7, 0x3e, 0x9b, 0xe8, 0x13, 0x89, 0xac, 0xf1, 0x45, 0xa8,
	0xf7, 0x2b, 0x9c, 0x6e, 0xaf, 0x7e, 0x5b, 0x54, 0x75, 0x09, 0x3a, 0xf8, 0xfb, 0x95, 0xd0, 0xf0,
	0x04, 0x5b, 0xf3, 0x59, 0x2c, 0xe4, 0x09, 0xa6, 0x2f, 0xd4, 0x63, 0x2a, 0x9e, 0x1d, 0x9b, 0xb4,
	0x90, 0x9c, 0xd1, 0x14, 0x81, 0x70, 0x57, 0x3e, 0x34, 0x12, 0x0f, 0x50, 0x07, 0x6a, 0x3e, 0x00,
	0x5a, 0x70, 0xa2, 0x11, 0x11, 0x08, 0x2d, 0xf6, 0x56, 0x04, 0x55, 0xd7, 0x2e, 0xfc, 0x8f, 0xc8,
	0x81, 0xb9, 0xf4, 0x94, 0x2d, 0xc5, 0x2e, 0x08, 0x2b, 0x59, 0x34, 0x6a, 0x99, 0xeb, 0xa8, 0xef,
	0x93, 0xc3, 0x9a, 0x03, 0x08, 0x09, 0x06, 0x00, 0xfa, 0xee, 0x78, 0x1f, 0x90, 0x1e, 0x98, 0x3f,
	0xa7, 0xc5, 0x19, 0x8b, 0xcc, 0x1b, 0x39, 0x9b, 0x97, 0x4c, 0xd8, 0x70, 0x20, 0x1d, 0x86, 0x0a,
	0x01, 0x46, 0xc1, 0xd2, 0xf9, 0x1f, 0x92, 0x7e, 0xe5, 0x1a, 0xc4, 0x00, 0x34, 0x8b, 0x73, 0x2a,
	0x98, 0x41, 0x66, 0x40, 0x5c, 0x0e, 0xdb, 0x79, 0x26, 0x98, 0x21, 0x89, 0x0d, 0xab, 0xfb, 0xf2,
	0xef, 0x06, 0xe9, 0x82, 0x83, 0x27, 0x59, 0xc4, 0x2e, 0x77, 0x3d, 0x12, 0xdc, 0xc5, 0xea, 0xcc,
	0x30, 0xe5, 0x5d, 0xd2, 0x9a, 0x9b, 0x37, 0x36, 0x8e, 0x0f, 0xee, 0xdf, 0x19, 0x55, 0xee, 0x8e,
	0xf0, 0xc7, 0xe7, 0x25, 0xe3, 0xcb, 0x2f, 0xc0, 0xc4, 0x52, 0xac, 0x69, 0x25, 0x81, 0x2b, 0x3d,
	0x08, 0xd2, 0x38, 0x43, 0x3a, 0x55, 0xb7, 0xe8, 0x25, 0xd2, 0x0a, 0xdf, 0x68, 0x9a, 0x4c, 0x32,
	0x9e, 0x0a, 0xd3, 0xb6, 0xeb, 0xea, 0xba, 0xb6, 0x15, 0xe1, 0x4a, 0x00, 0xef, 0x2a, 0x13, 0xa8,
	0x5e, 0xc7, 0x2a, 0xab, 0x82, 0x27, 0xce, 0x4a, 0x2a, 0xe3, 0x3c, 0x43, 0xca, 0xd5, 0x6a, 0xd4,
	0xad, 0xd5, 0xa8, 0x87, 0xc7, 0xc0, 0x57, 0x15, 0x08, 0x5c, 0x4d, 0xe1, 0x89, 0xc8, 0x38, 0x25,
	0x0c, 0x05, 0x9d, 0xc6, 0x19, 0xba, 0x09, 0x44, 0xce, 0xa5, 0x69, 0x5b, 0xa0, 0x6f, 0x98, 0x2f,
	0x18, 0x0f, 0xb0, 0x0c, 0x97, 0x12, 0xdb, 0xb7, 0xb7, 0xa9, 0x34, 0x03, 0x84, 0xf5, 0x4d, 0x72,
	0xb0, 0x81, 0xc6, 0x3e, 0x69, 0xb0, 0xf9, 0xe0, 0x1a, 0x34, 0x51, 0x0b, 0x5f, 0x3d, 0x70, 0xfc,
	0x6f, 0xb1, 0xe4, 0x06, 0xbe, 0x2d, 0x7a, 0xdc, 0x52, 0x04, 0xd0, 0x2f, 0x6c, 0x60, 0xeb, 0xbb,
	0x0a, 0xec, 0x53, 0x1a, 0xf3, 0xad, 0xb7, 0xee, 0xd5, 0x0a, 0xdb, 0xc4, 0x0c, 0xbe, 0x26, 0x03,
	0xeb, 0xfc, 0x04, 0xf2, 0xc2, 0x00, 0xf7, 0x48, 0x3b, 0x1f, 0x7f, 0xc7, 0x42, 0x43, 0xf9, 0xee,
	0xfd, 0xc3, 0x55, 0xfd, 0x3e, 0xc3, 0xfd, 0x2d, 0xcf, 0xbb, 0x28, 0xf3, 0xab, 0x83, 0xad, 0xf1,
	0xe8, 0x85, 0xee, 0xa6, 0x5d, 0xac, 0x81, 0xd2, 0x0a, 0x49, 0xb9, 0x0c, 0xd6, 0x1a, 0x03, 0x95,
	0x60, 0x30, 0xde, 0x56, 0xfa, 0x34, 0xf4, 0x08, 0xd1, 0x36, 0x71, 0x16, 0x26, 0x3a, 0xe9, 0x87,
	0x4d, 0xc9, 0x4b, 0x06, 0x15, 0x70, 0x95, 0x29, 0xee, 0xe3, 0x80, 0x7c, 0xd8, 0x9a, 0xd0, 0x44,
	0xb0, 0xad, 0xec, 0xf6, 0x6d, 0x01, 0xaa, 0x74, 0x68, 0x6f, 0x8a, 0x8f, 0x5b, 0x2b, 0x7c, 0x07,
	0xef, 0x6c, 0xd5, 0x12, 0xe9, 0xe2, 0x7f, 0x85, 0x3d, 0xbb, 0x7e, 0xd9, 0x2b, 0xc3, 0xec, 0x21,
	0x42, 0x56, 0xbd, 0x65, 0xba, 0x43, 0xe3, 0x75, 0x87, 0xec, 0xeb, 0x20, 0x08, 0x96, 0x51, 0x79,
	0x33, 0x7b, 0xfd, 0xbf, 0x1c, 0x1c, 0x09, 0x56, 0xf4, 0xa1, 0x23, 0x41, 0x2c, 0x4b, 0xf6, 0x52,
	0x59, 0x30, 0xbc, 0x87, 0xf9, 0xcb, 0x05, 0x54, 0xc4, 0xa2, 0x3d, 0xb0, 0x66, 0x2c, 0x0b, 0x61,
	0xe2, 0x65, 0x53, 0xd3, 0x99, 0x90, 0xe8, 0x42, 0xd2, 0xa9, 0x69, 0xca, 0x9b, 0xa4, 0x95, 0xc4,
	0xd9, 0x4c, 0x00, 0xb6, 0x2b, 0xce, 0x3d, 0x83, 0x0d, 0x25, 0x24, 0x09, 0x15, 0x38, 0x2d, 0x0d,
	0xc4, 0xaf, 0x93, 0x03, 0xbb, 0x13, 0x94, 0x82, 0x85, 0xc2, 0x20, 0x7d, 0x9b, 0xb8, 0xb0, 0xe4,
	0x29, 0x93, 0x14, 0xd0, 0xae, 0x33, 0x17, 0x48, 0x8d, 0x72, 0xc2, 0x04, 0x20, 0x5e, 0x3f, 0x82,
	0x94, 0xcd, 0xc7, 0x8c, 0x9e, 0x0b, 0x20, 0xdb, 0x6d, 0x1b, 0xbc, 0xca, 0x2f, 0x67, 0xf3, 0x7b,
	0x01, 0x16, 0x2a, 0x7f, 0xad, 0xba, 0xdf, 0x93, 0xeb, 0x88, 0x55, 0x09, 0x6f, 0xe5, 0x5f, 0x16,
	0x11, 0x95, 0xec, 0xca, 0xf1, 0x07, 0x87, 0x34, 0x55, 0x37, 0x50, 0xd5, 0x86, 0x7a, 0xce, 0x35,
	0x2b, 0xf3, 0xac, 0x55, 0x99, 0x73, 0x1b, 0x9f, 0x17, 0xba, 0x14, 0xa8, 0x53, 0xfe, 0x5b, 0xe4,
	0xc6, 0x76, 0x6c, 0x2d, 0xc9, 0xb6, 0x62, 0xce, 0xf1, 0xd0, 0x9f, 0x63, 0x67, 0x1a, 0xb3, 0xff,
	0xe5, 0x5b, 0xd2, 0xf7, 0x71, 0x8a, 0x56, 0x43, 0x6e, 0xa7, 0xf5, 0x98, 0xdc, 0xd6, 0xa4, 0xd3,
	0xe4, 0x87, 0xa1, 0x75, 0xca, 0xd9, 0x24, 0x81, 0xf9, 0x75, 0x65, 0x82, 0xf5, 0xc1, 0xf7, 0x29,
	0xb9, 0xf3, 0x52, 0x47, 0x10, 0xf6, 0x3d, 0xe2, 0x16, 0x66, 0x6d, 0x3a, 0xea, 0x96, 0xe2, 0xc0,
	0x96, 0xf1, 0x13, 0xc9, 0x52, 0xff, 0x19, 0xf1, 0x5e, 0x76, 0xa6, 0x44, 0xa6, 0x00, 0xfd, 0x88,
	0xb1, 0xe9, 0x54, 0x56, 0x7b, 0x2a, 0x91, 0x2c, 0x8f, 0xd8, 0x5a, 0x72, 0x0a, 0x1e, 0xa7, 0x94,
	0x2f, 0xb1, 0xb0, 0xae, 0x7f, 0xa9, 0x85, 0x4b, 0x35, 0x3e, 0x9d, 0x22, 0x2f, 0x6c, 0xe6, 0x8e,
	0xfd, 0xf2, 0x34, 0x8f, 0xd4, 0x0e, 0x80, 0xe1, 0x30, 0xae, 0x82, 0x55, 0x14, 0x61, 0xaa, 0x00,
	0xea, 0xc1, 0x59, 0x91, 0xd0, 0x90, 0x05, 0xa8, 0x22, 0xa6, 0x93, 0x6e, 0x91, 0xa3, 0x32, 0xa3,
	0x0b, 0x1a, 0x27, 0x74, 0x9c, 0xd8, 0xa3, 0x96, 0x12, 0x73, 0x98, 0xee, 0x87, 0xb5, 0xc8, 0x80,
	0x83, 0xaf, 0x04, 0x51, 0xf2, 0x98, 0x59, 0x61, 0x39, 0x1a, 0x55, 0x4c, 0x3e, 0x81, 0xa3, 0xa5,
	0xff, 0x8d, 0xa1, 0x4a, 0x65, 0x4f, 0x51, 0x20, 0x2e, 0x4c, 0x15, 0x20, 0xfd, 0x42, 0x0d, 0x28,
	0x95, 0x2e, 0xa6, 0xa5, 0xe6, 0x47, 0xa1, 0xf2, 0x8a, 0x98, 0x08, 0x4d, 0xeb, 0x6f, 0x69, 0x9d,
	0xfa, 0x8a, 0xee, 0x9d, 0x3c, 0xf8, 0xf9, 0xf7, 0xbb, 0xce, 0x2f, 0xf0, 0xf7, 0x1b, 0xfc, 0xfd,
	0xf0, 0xc7, 0xdd, 0x6b, 0xe4, 0x66, 0x98, 0xa7, 0x23, 0xa0, 0xd4, 0x79, 0x3e, 0x5a, 0xff, 0x17,
	0x35, 0x2e, 0x27, 0x27, 0xee, 0x19, 0x2c, 0x9f, 0x2e, 0x4e, 0x4f, 0xfe, 0x09, 0x00, 0x00, 0xff,
	0xff, 0xa7, 0xf9, 0xec, 0x6f, 0x6e, 0x0d, 0x00, 0x00,
}
