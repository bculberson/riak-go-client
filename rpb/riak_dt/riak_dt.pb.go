// Code generated by protoc-gen-gogo.
// source: riak_dt.proto
// DO NOT EDIT!

/*
	Package riak_dt is a generated protocol buffer package.

	It is generated from these files:
		riak_dt.proto

	It has these top-level messages:
		MapField
		MapEntry
		DtFetchReq
		DtValue
		DtFetchResp
		CounterOp
		SetOp
		MapUpdate
		MapOp
		DtOp
		DtUpdateReq
		DtUpdateResp
*/
package riak_dt

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// The types that can be stored in a map are limited to counters,
// sets, registers, flags, and maps.
type MapField_MapFieldType int32

const (
	MapField_COUNTER  MapField_MapFieldType = 1
	MapField_SET      MapField_MapFieldType = 2
	MapField_REGISTER MapField_MapFieldType = 3
	MapField_FLAG     MapField_MapFieldType = 4
	MapField_MAP      MapField_MapFieldType = 5
)

var MapField_MapFieldType_name = map[int32]string{
	1: "COUNTER",
	2: "SET",
	3: "REGISTER",
	4: "FLAG",
	5: "MAP",
}
var MapField_MapFieldType_value = map[string]int32{
	"COUNTER":  1,
	"SET":      2,
	"REGISTER": 3,
	"FLAG":     4,
	"MAP":      5,
}

func (x MapField_MapFieldType) Enum() *MapField_MapFieldType {
	p := new(MapField_MapFieldType)
	*p = x
	return p
}
func (x MapField_MapFieldType) String() string {
	return proto.EnumName(MapField_MapFieldType_name, int32(x))
}
func (x *MapField_MapFieldType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MapField_MapFieldType_value, data, "MapField_MapFieldType")
	if err != nil {
		return err
	}
	*x = MapField_MapFieldType(value)
	return nil
}
func (MapField_MapFieldType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRiakDt, []int{0, 0}
}

type DtFetchResp_DataType int32

const (
	DtFetchResp_COUNTER DtFetchResp_DataType = 1
	DtFetchResp_SET     DtFetchResp_DataType = 2
	DtFetchResp_MAP     DtFetchResp_DataType = 3
)

var DtFetchResp_DataType_name = map[int32]string{
	1: "COUNTER",
	2: "SET",
	3: "MAP",
}
var DtFetchResp_DataType_value = map[string]int32{
	"COUNTER": 1,
	"SET":     2,
	"MAP":     3,
}

func (x DtFetchResp_DataType) Enum() *DtFetchResp_DataType {
	p := new(DtFetchResp_DataType)
	*p = x
	return p
}
func (x DtFetchResp_DataType) String() string {
	return proto.EnumName(DtFetchResp_DataType_name, int32(x))
}
func (x *DtFetchResp_DataType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DtFetchResp_DataType_value, data, "DtFetchResp_DataType")
	if err != nil {
		return err
	}
	*x = DtFetchResp_DataType(value)
	return nil
}
func (DtFetchResp_DataType) EnumDescriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{4, 0} }

//
// Flags only exist inside Maps and can only be enabled or
// disabled, and there are no arguments to the operations.
type MapUpdate_FlagOp int32

const (
	MapUpdate_ENABLE  MapUpdate_FlagOp = 1
	MapUpdate_DISABLE MapUpdate_FlagOp = 2
)

var MapUpdate_FlagOp_name = map[int32]string{
	1: "ENABLE",
	2: "DISABLE",
}
var MapUpdate_FlagOp_value = map[string]int32{
	"ENABLE":  1,
	"DISABLE": 2,
}

func (x MapUpdate_FlagOp) Enum() *MapUpdate_FlagOp {
	p := new(MapUpdate_FlagOp)
	*p = x
	return p
}
func (x MapUpdate_FlagOp) String() string {
	return proto.EnumName(MapUpdate_FlagOp_name, int32(x))
}
func (x *MapUpdate_FlagOp) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MapUpdate_FlagOp_value, data, "MapUpdate_FlagOp")
	if err != nil {
		return err
	}
	*x = MapUpdate_FlagOp(value)
	return nil
}
func (MapUpdate_FlagOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{7, 0} }

//
// Field names in maps are composed of a binary identifier and a type.
// This is so that two clients can create fields with the same name
// but different types, and they converge independently.
type MapField struct {
	Name             []byte                 `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Type             *MapField_MapFieldType `protobuf:"varint,2,req,name=type,enum=MapField_MapFieldType" json:"type,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *MapField) Reset()                    { *m = MapField{} }
func (m *MapField) String() string            { return proto.CompactTextString(m) }
func (*MapField) ProtoMessage()               {}
func (*MapField) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{0} }

func (m *MapField) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *MapField) GetType() MapField_MapFieldType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return MapField_COUNTER
}

//
// An entry in a map is a pair of a field-name and value. The type
// defined in the field determines which value type is expected.
type MapEntry struct {
	Field            *MapField   `protobuf:"bytes,1,req,name=field" json:"field,omitempty"`
	CounterValue     *int64      `protobuf:"zigzag64,2,opt,name=counter_value" json:"counter_value,omitempty"`
	SetValue         [][]byte    `protobuf:"bytes,3,rep,name=set_value" json:"set_value,omitempty"`
	RegisterValue    []byte      `protobuf:"bytes,4,opt,name=register_value" json:"register_value,omitempty"`
	FlagValue        *bool       `protobuf:"varint,5,opt,name=flag_value" json:"flag_value,omitempty"`
	MapValue         []*MapEntry `protobuf:"bytes,6,rep,name=map_value" json:"map_value,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *MapEntry) Reset()                    { *m = MapEntry{} }
func (m *MapEntry) String() string            { return proto.CompactTextString(m) }
func (*MapEntry) ProtoMessage()               {}
func (*MapEntry) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{1} }

func (m *MapEntry) GetField() *MapField {
	if m != nil {
		return m.Field
	}
	return nil
}

func (m *MapEntry) GetCounterValue() int64 {
	if m != nil && m.CounterValue != nil {
		return *m.CounterValue
	}
	return 0
}

func (m *MapEntry) GetSetValue() [][]byte {
	if m != nil {
		return m.SetValue
	}
	return nil
}

func (m *MapEntry) GetRegisterValue() []byte {
	if m != nil {
		return m.RegisterValue
	}
	return nil
}

func (m *MapEntry) GetFlagValue() bool {
	if m != nil && m.FlagValue != nil {
		return *m.FlagValue
	}
	return false
}

func (m *MapEntry) GetMapValue() []*MapEntry {
	if m != nil {
		return m.MapValue
	}
	return nil
}

//
// The equivalent of KV's "RpbGetReq", results in a DtFetchResp. The
// request-time options are limited to ones that are relevant to
// structured data-types.
type DtFetchReq struct {
	// The identifier: bucket, key and bucket-type
	Bucket []byte `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Key    []byte `protobuf:"bytes,2,req,name=key" json:"key,omitempty"`
	Type   []byte `protobuf:"bytes,3,req,name=type" json:"type,omitempty"`
	// Request options
	R            *uint32 `protobuf:"varint,4,opt,name=r" json:"r,omitempty"`
	Pr           *uint32 `protobuf:"varint,5,opt,name=pr" json:"pr,omitempty"`
	BasicQuorum  *bool   `protobuf:"varint,6,opt,name=basic_quorum" json:"basic_quorum,omitempty"`
	NotfoundOk   *bool   `protobuf:"varint,7,opt,name=notfound_ok" json:"notfound_ok,omitempty"`
	Timeout      *uint32 `protobuf:"varint,8,opt,name=timeout" json:"timeout,omitempty"`
	SloppyQuorum *bool   `protobuf:"varint,9,opt,name=sloppy_quorum" json:"sloppy_quorum,omitempty"`
	NVal         *uint32 `protobuf:"varint,10,opt,name=n_val" json:"n_val,omitempty"`
	// For read-only requests or context-free operations, you can set
	// this to false to reduce the size of the response payload.
	IncludeContext   *bool  `protobuf:"varint,11,opt,name=include_context,def=1" json:"include_context,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DtFetchReq) Reset()                    { *m = DtFetchReq{} }
func (m *DtFetchReq) String() string            { return proto.CompactTextString(m) }
func (*DtFetchReq) ProtoMessage()               {}
func (*DtFetchReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{2} }

const Default_DtFetchReq_IncludeContext bool = true

func (m *DtFetchReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *DtFetchReq) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *DtFetchReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DtFetchReq) GetR() uint32 {
	if m != nil && m.R != nil {
		return *m.R
	}
	return 0
}

func (m *DtFetchReq) GetPr() uint32 {
	if m != nil && m.Pr != nil {
		return *m.Pr
	}
	return 0
}

func (m *DtFetchReq) GetBasicQuorum() bool {
	if m != nil && m.BasicQuorum != nil {
		return *m.BasicQuorum
	}
	return false
}

func (m *DtFetchReq) GetNotfoundOk() bool {
	if m != nil && m.NotfoundOk != nil {
		return *m.NotfoundOk
	}
	return false
}

func (m *DtFetchReq) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *DtFetchReq) GetSloppyQuorum() bool {
	if m != nil && m.SloppyQuorum != nil {
		return *m.SloppyQuorum
	}
	return false
}

func (m *DtFetchReq) GetNVal() uint32 {
	if m != nil && m.NVal != nil {
		return *m.NVal
	}
	return 0
}

func (m *DtFetchReq) GetIncludeContext() bool {
	if m != nil && m.IncludeContext != nil {
		return *m.IncludeContext
	}
	return Default_DtFetchReq_IncludeContext
}

//
// The value of the fetched data type. If present in the response,
// then empty values (sets, maps) should be treated as such.
type DtValue struct {
	CounterValue     *int64      `protobuf:"zigzag64,1,opt,name=counter_value" json:"counter_value,omitempty"`
	SetValue         [][]byte    `protobuf:"bytes,2,rep,name=set_value" json:"set_value,omitempty"`
	MapValue         []*MapEntry `protobuf:"bytes,3,rep,name=map_value" json:"map_value,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *DtValue) Reset()                    { *m = DtValue{} }
func (m *DtValue) String() string            { return proto.CompactTextString(m) }
func (*DtValue) ProtoMessage()               {}
func (*DtValue) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{3} }

func (m *DtValue) GetCounterValue() int64 {
	if m != nil && m.CounterValue != nil {
		return *m.CounterValue
	}
	return 0
}

func (m *DtValue) GetSetValue() [][]byte {
	if m != nil {
		return m.SetValue
	}
	return nil
}

func (m *DtValue) GetMapValue() []*MapEntry {
	if m != nil {
		return m.MapValue
	}
	return nil
}

//
// The response to a "Fetch" request. If the `include_context` option
// is specified, an opaque "context" value will be returned along with
// the user-friendly data. When sending an "Update" request, the
// client should send this context as well, similar to how one would
// send a vclock for KV updates. The `type` field indicates which
// value type to expect. When the `value` field is missing from the
// message, the client should interpret it as a "not found".
type DtFetchResp struct {
	Context          []byte                `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Type             *DtFetchResp_DataType `protobuf:"varint,2,req,name=type,enum=DtFetchResp_DataType" json:"type,omitempty"`
	Value            *DtValue              `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *DtFetchResp) Reset()                    { *m = DtFetchResp{} }
func (m *DtFetchResp) String() string            { return proto.CompactTextString(m) }
func (*DtFetchResp) ProtoMessage()               {}
func (*DtFetchResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{4} }

func (m *DtFetchResp) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *DtFetchResp) GetType() DtFetchResp_DataType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return DtFetchResp_COUNTER
}

func (m *DtFetchResp) GetValue() *DtValue {
	if m != nil {
		return m.Value
	}
	return nil
}

//
// An operation to update a Counter, either on its own or inside a
// Map. The `increment` field can be positive or negative. When absent,
// the meaning is an increment by 1.
type CounterOp struct {
	Increment        *int64 `protobuf:"zigzag64,1,opt,name=increment" json:"increment,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CounterOp) Reset()                    { *m = CounterOp{} }
func (m *CounterOp) String() string            { return proto.CompactTextString(m) }
func (*CounterOp) ProtoMessage()               {}
func (*CounterOp) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{5} }

func (m *CounterOp) GetIncrement() int64 {
	if m != nil && m.Increment != nil {
		return *m.Increment
	}
	return 0
}

//
// An operation to update a Set, either on its own or inside a Map.
// Set members are opaque binary values, you can only add or remove
// them from a Set.
type SetOp struct {
	Adds             [][]byte `protobuf:"bytes,1,rep,name=adds" json:"adds,omitempty"`
	Removes          [][]byte `protobuf:"bytes,2,rep,name=removes" json:"removes,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *SetOp) Reset()                    { *m = SetOp{} }
func (m *SetOp) String() string            { return proto.CompactTextString(m) }
func (*SetOp) ProtoMessage()               {}
func (*SetOp) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{6} }

func (m *SetOp) GetAdds() [][]byte {
	if m != nil {
		return m.Adds
	}
	return nil
}

func (m *SetOp) GetRemoves() [][]byte {
	if m != nil {
		return m.Removes
	}
	return nil
}

//
// An operation to be applied to a value stored in a Map -- the
// contents of an UPDATE operation. The operation field that is
// present depends on the type of the field to which it is applied.
type MapUpdate struct {
	Field     *MapField  `protobuf:"bytes,1,req,name=field" json:"field,omitempty"`
	CounterOp *CounterOp `protobuf:"bytes,2,opt,name=counter_op" json:"counter_op,omitempty"`
	SetOp     *SetOp     `protobuf:"bytes,3,opt,name=set_op" json:"set_op,omitempty"`
	//
	// There is only one operation on a register, which is to set its
	// value, therefore the "operation" is the new value.
	RegisterOp       []byte            `protobuf:"bytes,4,opt,name=register_op" json:"register_op,omitempty"`
	FlagOp           *MapUpdate_FlagOp `protobuf:"varint,5,opt,name=flag_op,enum=MapUpdate_FlagOp" json:"flag_op,omitempty"`
	MapOp            *MapOp            `protobuf:"bytes,6,opt,name=map_op" json:"map_op,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *MapUpdate) Reset()                    { *m = MapUpdate{} }
func (m *MapUpdate) String() string            { return proto.CompactTextString(m) }
func (*MapUpdate) ProtoMessage()               {}
func (*MapUpdate) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{7} }

func (m *MapUpdate) GetField() *MapField {
	if m != nil {
		return m.Field
	}
	return nil
}

func (m *MapUpdate) GetCounterOp() *CounterOp {
	if m != nil {
		return m.CounterOp
	}
	return nil
}

func (m *MapUpdate) GetSetOp() *SetOp {
	if m != nil {
		return m.SetOp
	}
	return nil
}

func (m *MapUpdate) GetRegisterOp() []byte {
	if m != nil {
		return m.RegisterOp
	}
	return nil
}

func (m *MapUpdate) GetFlagOp() MapUpdate_FlagOp {
	if m != nil && m.FlagOp != nil {
		return *m.FlagOp
	}
	return MapUpdate_ENABLE
}

func (m *MapUpdate) GetMapOp() *MapOp {
	if m != nil {
		return m.MapOp
	}
	return nil
}

//
// An operation to update a Map. All operations apply to individual
// fields in the Map.
type MapOp struct {
	//
	//  REMOVE removes a field and value from the Map.
	// UPDATE applies type-specific
	// operations to the values stored in the Map.
	Removes          []*MapField  `protobuf:"bytes,1,rep,name=removes" json:"removes,omitempty"`
	Updates          []*MapUpdate `protobuf:"bytes,2,rep,name=updates" json:"updates,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *MapOp) Reset()                    { *m = MapOp{} }
func (m *MapOp) String() string            { return proto.CompactTextString(m) }
func (*MapOp) ProtoMessage()               {}
func (*MapOp) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{8} }

func (m *MapOp) GetRemoves() []*MapField {
	if m != nil {
		return m.Removes
	}
	return nil
}

func (m *MapOp) GetUpdates() []*MapUpdate {
	if m != nil {
		return m.Updates
	}
	return nil
}

//
// A "union" type for update operations. The included operation
// depends on the datatype being updated.
type DtOp struct {
	CounterOp        *CounterOp `protobuf:"bytes,1,opt,name=counter_op" json:"counter_op,omitempty"`
	SetOp            *SetOp     `protobuf:"bytes,2,opt,name=set_op" json:"set_op,omitempty"`
	MapOp            *MapOp     `protobuf:"bytes,3,opt,name=map_op" json:"map_op,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *DtOp) Reset()                    { *m = DtOp{} }
func (m *DtOp) String() string            { return proto.CompactTextString(m) }
func (*DtOp) ProtoMessage()               {}
func (*DtOp) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{9} }

func (m *DtOp) GetCounterOp() *CounterOp {
	if m != nil {
		return m.CounterOp
	}
	return nil
}

func (m *DtOp) GetSetOp() *SetOp {
	if m != nil {
		return m.SetOp
	}
	return nil
}

func (m *DtOp) GetMapOp() *MapOp {
	if m != nil {
		return m.MapOp
	}
	return nil
}

//
// The equivalent of KV's "RpbPutReq", results in an empty response or
// "DtUpdateResp" if `return_body` is specified, or the key is
// assigned by the server. The request-time options are limited to
// ones that are relevant to structured data-types.
type DtUpdateReq struct {
	// The identifier
	Bucket []byte `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Key    []byte `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Type   []byte `protobuf:"bytes,3,req,name=type" json:"type,omitempty"`
	// Opaque update-context
	Context []byte `protobuf:"bytes,4,opt,name=context" json:"context,omitempty"`
	// The operations
	Op *DtOp `protobuf:"bytes,5,req,name=op" json:"op,omitempty"`
	// Request options
	W                *uint32 `protobuf:"varint,6,opt,name=w" json:"w,omitempty"`
	Dw               *uint32 `protobuf:"varint,7,opt,name=dw" json:"dw,omitempty"`
	Pw               *uint32 `protobuf:"varint,8,opt,name=pw" json:"pw,omitempty"`
	ReturnBody       *bool   `protobuf:"varint,9,opt,name=return_body,def=0" json:"return_body,omitempty"`
	Timeout          *uint32 `protobuf:"varint,10,opt,name=timeout" json:"timeout,omitempty"`
	SloppyQuorum     *bool   `protobuf:"varint,11,opt,name=sloppy_quorum" json:"sloppy_quorum,omitempty"`
	NVal             *uint32 `protobuf:"varint,12,opt,name=n_val" json:"n_val,omitempty"`
	IncludeContext   *bool   `protobuf:"varint,13,opt,name=include_context,def=1" json:"include_context,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DtUpdateReq) Reset()                    { *m = DtUpdateReq{} }
func (m *DtUpdateReq) String() string            { return proto.CompactTextString(m) }
func (*DtUpdateReq) ProtoMessage()               {}
func (*DtUpdateReq) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{10} }

const Default_DtUpdateReq_ReturnBody bool = false
const Default_DtUpdateReq_IncludeContext bool = true

func (m *DtUpdateReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *DtUpdateReq) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *DtUpdateReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DtUpdateReq) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *DtUpdateReq) GetOp() *DtOp {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *DtUpdateReq) GetW() uint32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *DtUpdateReq) GetDw() uint32 {
	if m != nil && m.Dw != nil {
		return *m.Dw
	}
	return 0
}

func (m *DtUpdateReq) GetPw() uint32 {
	if m != nil && m.Pw != nil {
		return *m.Pw
	}
	return 0
}

func (m *DtUpdateReq) GetReturnBody() bool {
	if m != nil && m.ReturnBody != nil {
		return *m.ReturnBody
	}
	return Default_DtUpdateReq_ReturnBody
}

func (m *DtUpdateReq) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *DtUpdateReq) GetSloppyQuorum() bool {
	if m != nil && m.SloppyQuorum != nil {
		return *m.SloppyQuorum
	}
	return false
}

func (m *DtUpdateReq) GetNVal() uint32 {
	if m != nil && m.NVal != nil {
		return *m.NVal
	}
	return 0
}

func (m *DtUpdateReq) GetIncludeContext() bool {
	if m != nil && m.IncludeContext != nil {
		return *m.IncludeContext
	}
	return Default_DtUpdateReq_IncludeContext
}

//
// The equivalent of KV's "RpbPutResp", contains the assigned key if
// it was assigned by the server, and the resulting value and context
// if return_body was set.
type DtUpdateResp struct {
	// The key, if assigned by the server
	Key []byte `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// The opaque update context and value, if return_body was set.
	Context          []byte      `protobuf:"bytes,2,opt,name=context" json:"context,omitempty"`
	CounterValue     *int64      `protobuf:"zigzag64,3,opt,name=counter_value" json:"counter_value,omitempty"`
	SetValue         [][]byte    `protobuf:"bytes,4,rep,name=set_value" json:"set_value,omitempty"`
	MapValue         []*MapEntry `protobuf:"bytes,5,rep,name=map_value" json:"map_value,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *DtUpdateResp) Reset()                    { *m = DtUpdateResp{} }
func (m *DtUpdateResp) String() string            { return proto.CompactTextString(m) }
func (*DtUpdateResp) ProtoMessage()               {}
func (*DtUpdateResp) Descriptor() ([]byte, []int) { return fileDescriptorRiakDt, []int{11} }

func (m *DtUpdateResp) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *DtUpdateResp) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *DtUpdateResp) GetCounterValue() int64 {
	if m != nil && m.CounterValue != nil {
		return *m.CounterValue
	}
	return 0
}

func (m *DtUpdateResp) GetSetValue() [][]byte {
	if m != nil {
		return m.SetValue
	}
	return nil
}

func (m *DtUpdateResp) GetMapValue() []*MapEntry {
	if m != nil {
		return m.MapValue
	}
	return nil
}

func init() {
	proto.RegisterType((*MapField)(nil), "MapField")
	proto.RegisterType((*MapEntry)(nil), "MapEntry")
	proto.RegisterType((*DtFetchReq)(nil), "DtFetchReq")
	proto.RegisterType((*DtValue)(nil), "DtValue")
	proto.RegisterType((*DtFetchResp)(nil), "DtFetchResp")
	proto.RegisterType((*CounterOp)(nil), "CounterOp")
	proto.RegisterType((*SetOp)(nil), "SetOp")
	proto.RegisterType((*MapUpdate)(nil), "MapUpdate")
	proto.RegisterType((*MapOp)(nil), "MapOp")
	proto.RegisterType((*DtOp)(nil), "DtOp")
	proto.RegisterType((*DtUpdateReq)(nil), "DtUpdateReq")
	proto.RegisterType((*DtUpdateResp)(nil), "DtUpdateResp")
	proto.RegisterEnum("MapField_MapFieldType", MapField_MapFieldType_name, MapField_MapFieldType_value)
	proto.RegisterEnum("DtFetchResp_DataType", DtFetchResp_DataType_name, DtFetchResp_DataType_value)
	proto.RegisterEnum("MapUpdate_FlagOp", MapUpdate_FlagOp_name, MapUpdate_FlagOp_value)
}
func (m *MapField) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MapField) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x10
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MapEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MapEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Field == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.Field.Size()))
		n1, err := m.Field.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.CounterValue != nil {
		data[i] = 0x10
		i++
		i = encodeVarintRiakDt(data, i, uint64((uint64(*m.CounterValue)<<1)^uint64((*m.CounterValue>>63))))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			data[i] = 0x1a
			i++
			i = encodeVarintRiakDt(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if m.RegisterValue != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.RegisterValue)))
		i += copy(data[i:], m.RegisterValue)
	}
	if m.FlagValue != nil {
		data[i] = 0x28
		i++
		if *m.FlagValue {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.MapValue) > 0 {
		for _, msg := range m.MapValue {
			data[i] = 0x32
			i++
			i = encodeVarintRiakDt(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DtFetchReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtFetchReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.R != nil {
		data[i] = 0x20
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.R))
	}
	if m.Pr != nil {
		data[i] = 0x28
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Pr))
	}
	if m.BasicQuorum != nil {
		data[i] = 0x30
		i++
		if *m.BasicQuorum {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NotfoundOk != nil {
		data[i] = 0x38
		i++
		if *m.NotfoundOk {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Timeout != nil {
		data[i] = 0x40
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		data[i] = 0x48
		i++
		if *m.SloppyQuorum {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NVal != nil {
		data[i] = 0x50
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.NVal))
	}
	if m.IncludeContext != nil {
		data[i] = 0x58
		i++
		if *m.IncludeContext {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DtValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtValue) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CounterValue != nil {
		data[i] = 0x8
		i++
		i = encodeVarintRiakDt(data, i, uint64((uint64(*m.CounterValue)<<1)^uint64((*m.CounterValue>>63))))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			data[i] = 0x12
			i++
			i = encodeVarintRiakDt(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if len(m.MapValue) > 0 {
		for _, msg := range m.MapValue {
			data[i] = 0x1a
			i++
			i = encodeVarintRiakDt(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DtFetchResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtFetchResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Context)))
		i += copy(data[i:], m.Context)
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x10
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Type))
	}
	if m.Value != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.Value.Size()))
		n2, err := m.Value.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CounterOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CounterOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Increment != nil {
		data[i] = 0x8
		i++
		i = encodeVarintRiakDt(data, i, uint64((uint64(*m.Increment)<<1)^uint64((*m.Increment>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Adds) > 0 {
		for _, b := range m.Adds {
			data[i] = 0xa
			i++
			i = encodeVarintRiakDt(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if len(m.Removes) > 0 {
		for _, b := range m.Removes {
			data[i] = 0x12
			i++
			i = encodeVarintRiakDt(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MapUpdate) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MapUpdate) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Field == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.Field.Size()))
		n3, err := m.Field.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.CounterOp != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.CounterOp.Size()))
		n4, err := m.CounterOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.SetOp != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.SetOp.Size()))
		n5, err := m.SetOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.RegisterOp != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.RegisterOp)))
		i += copy(data[i:], m.RegisterOp)
	}
	if m.FlagOp != nil {
		data[i] = 0x28
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.FlagOp))
	}
	if m.MapOp != nil {
		data[i] = 0x32
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.MapOp.Size()))
		n6, err := m.MapOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MapOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MapOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Removes) > 0 {
		for _, msg := range m.Removes {
			data[i] = 0xa
			i++
			i = encodeVarintRiakDt(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Updates) > 0 {
		for _, msg := range m.Updates {
			data[i] = 0x12
			i++
			i = encodeVarintRiakDt(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DtOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CounterOp != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.CounterOp.Size()))
		n7, err := m.CounterOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.SetOp != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.SetOp.Size()))
		n8, err := m.SetOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.MapOp != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.MapOp.Size()))
		n9, err := m.MapOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DtUpdateReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtUpdateReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Key != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Context != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Context)))
		i += copy(data[i:], m.Context)
	}
	if m.Op == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x2a
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.Op.Size()))
		n10, err := m.Op.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.W != nil {
		data[i] = 0x30
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.W))
	}
	if m.Dw != nil {
		data[i] = 0x38
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Dw))
	}
	if m.Pw != nil {
		data[i] = 0x40
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Pw))
	}
	if m.ReturnBody != nil {
		data[i] = 0x48
		i++
		if *m.ReturnBody {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Timeout != nil {
		data[i] = 0x50
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		data[i] = 0x58
		i++
		if *m.SloppyQuorum {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NVal != nil {
		data[i] = 0x60
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.NVal))
	}
	if m.IncludeContext != nil {
		data[i] = 0x68
		i++
		if *m.IncludeContext {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DtUpdateResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtUpdateResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Context != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Context)))
		i += copy(data[i:], m.Context)
	}
	if m.CounterValue != nil {
		data[i] = 0x18
		i++
		i = encodeVarintRiakDt(data, i, uint64((uint64(*m.CounterValue)<<1)^uint64((*m.CounterValue>>63))))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			data[i] = 0x22
			i++
			i = encodeVarintRiakDt(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if len(m.MapValue) > 0 {
		for _, msg := range m.MapValue {
			data[i] = 0x2a
			i++
			i = encodeVarintRiakDt(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64RiakDt(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32RiakDt(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRiakDt(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *MapField) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(m.Name)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovRiakDt(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MapEntry) Size() (n int) {
	var l int
	_ = l
	if m.Field != nil {
		l = m.Field.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.CounterValue != nil {
		n += 1 + sozRiakDt(uint64(*m.CounterValue))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			l = len(b)
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.RegisterValue != nil {
		l = len(m.RegisterValue)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.FlagValue != nil {
		n += 2
	}
	if len(m.MapValue) > 0 {
		for _, e := range m.MapValue {
			l = e.Size()
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DtFetchReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.R != nil {
		n += 1 + sovRiakDt(uint64(*m.R))
	}
	if m.Pr != nil {
		n += 1 + sovRiakDt(uint64(*m.Pr))
	}
	if m.BasicQuorum != nil {
		n += 2
	}
	if m.NotfoundOk != nil {
		n += 2
	}
	if m.Timeout != nil {
		n += 1 + sovRiakDt(uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		n += 2
	}
	if m.NVal != nil {
		n += 1 + sovRiakDt(uint64(*m.NVal))
	}
	if m.IncludeContext != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DtValue) Size() (n int) {
	var l int
	_ = l
	if m.CounterValue != nil {
		n += 1 + sozRiakDt(uint64(*m.CounterValue))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			l = len(b)
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if len(m.MapValue) > 0 {
		for _, e := range m.MapValue {
			l = e.Size()
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DtFetchResp) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = len(m.Context)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovRiakDt(uint64(*m.Type))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CounterOp) Size() (n int) {
	var l int
	_ = l
	if m.Increment != nil {
		n += 1 + sozRiakDt(uint64(*m.Increment))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetOp) Size() (n int) {
	var l int
	_ = l
	if len(m.Adds) > 0 {
		for _, b := range m.Adds {
			l = len(b)
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if len(m.Removes) > 0 {
		for _, b := range m.Removes {
			l = len(b)
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MapUpdate) Size() (n int) {
	var l int
	_ = l
	if m.Field != nil {
		l = m.Field.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.CounterOp != nil {
		l = m.CounterOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.SetOp != nil {
		l = m.SetOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.RegisterOp != nil {
		l = len(m.RegisterOp)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.FlagOp != nil {
		n += 1 + sovRiakDt(uint64(*m.FlagOp))
	}
	if m.MapOp != nil {
		l = m.MapOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MapOp) Size() (n int) {
	var l int
	_ = l
	if len(m.Removes) > 0 {
		for _, e := range m.Removes {
			l = e.Size()
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DtOp) Size() (n int) {
	var l int
	_ = l
	if m.CounterOp != nil {
		l = m.CounterOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.SetOp != nil {
		l = m.SetOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.MapOp != nil {
		l = m.MapOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DtUpdateReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Context != nil {
		l = len(m.Context)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Op != nil {
		l = m.Op.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.W != nil {
		n += 1 + sovRiakDt(uint64(*m.W))
	}
	if m.Dw != nil {
		n += 1 + sovRiakDt(uint64(*m.Dw))
	}
	if m.Pw != nil {
		n += 1 + sovRiakDt(uint64(*m.Pw))
	}
	if m.ReturnBody != nil {
		n += 2
	}
	if m.Timeout != nil {
		n += 1 + sovRiakDt(uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		n += 2
	}
	if m.NVal != nil {
		n += 1 + sovRiakDt(uint64(*m.NVal))
	}
	if m.IncludeContext != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DtUpdateResp) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Context != nil {
		l = len(m.Context)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.CounterValue != nil {
		n += 1 + sozRiakDt(uint64(*m.CounterValue))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			l = len(b)
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if len(m.MapValue) > 0 {
		for _, e := range m.MapValue {
			l = e.Size()
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRiakDt(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRiakDt(x uint64) (n int) {
	return sovRiakDt(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MapField) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], data[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v MapField_MapFieldType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (MapField_MapFieldType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapEntry) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Field == nil {
				m.Field = &MapField{}
			}
			if err := m.Field.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.CounterValue = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetValue = append(m.SetValue, make([]byte, postIndex-iNdEx))
			copy(m.SetValue[len(m.SetValue)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisterValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegisterValue = append(m.RegisterValue[:0], data[iNdEx:postIndex]...)
			if m.RegisterValue == nil {
				m.RegisterValue = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FlagValue = &b
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapValue = append(m.MapValue, &MapEntry{})
			if err := m.MapValue[len(m.MapValue)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DtFetchReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DtFetchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DtFetchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], data[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.R = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pr", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pr = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BasicQuorum = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotfoundOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NotfoundOk = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SloppyQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SloppyQuorum = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NVal", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NVal = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeContext", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IncludeContext = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DtValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DtValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DtValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.CounterValue = &v2
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetValue = append(m.SetValue, make([]byte, postIndex-iNdEx))
			copy(m.SetValue[len(m.SetValue)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapValue = append(m.MapValue, &MapEntry{})
			if err := m.MapValue[len(m.MapValue)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DtFetchResp) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DtFetchResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DtFetchResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], data[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v DtFetchResp_DataType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (DtFetchResp_DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &DtValue{}
			}
			if err := m.Value.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CounterOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CounterOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CounterOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Increment = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Adds = append(m.Adds, make([]byte, postIndex-iNdEx))
			copy(m.Adds[len(m.Adds)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Removes = append(m.Removes, make([]byte, postIndex-iNdEx))
			copy(m.Removes[len(m.Removes)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapUpdate) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Field == nil {
				m.Field = &MapField{}
			}
			if err := m.Field.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CounterOp == nil {
				m.CounterOp = &CounterOp{}
			}
			if err := m.CounterOp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetOp == nil {
				m.SetOp = &SetOp{}
			}
			if err := m.SetOp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisterOp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegisterOp = append(m.RegisterOp[:0], data[iNdEx:postIndex]...)
			if m.RegisterOp == nil {
				m.RegisterOp = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagOp", wireType)
			}
			var v MapUpdate_FlagOp
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (MapUpdate_FlagOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlagOp = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapOp == nil {
				m.MapOp = &MapOp{}
			}
			if err := m.MapOp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Removes = append(m.Removes, &MapField{})
			if err := m.Removes[len(m.Removes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, &MapUpdate{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DtOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DtOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DtOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CounterOp == nil {
				m.CounterOp = &CounterOp{}
			}
			if err := m.CounterOp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetOp == nil {
				m.SetOp = &SetOp{}
			}
			if err := m.SetOp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapOp == nil {
				m.MapOp = &MapOp{}
			}
			if err := m.MapOp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DtUpdateReq) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DtUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DtUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket[:0], data[iNdEx:postIndex]...)
			if m.Bucket == nil {
				m.Bucket = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], data[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], data[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Op == nil {
				m.Op = &DtOp{}
			}
			if err := m.Op.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.W = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dw", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dw = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pw", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pw = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnBody", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReturnBody = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SloppyQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SloppyQuorum = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NVal", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NVal = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeContext", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IncludeContext = &b
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DtUpdateResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DtUpdateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DtUpdateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], data[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.CounterValue = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetValue = append(m.SetValue, make([]byte, postIndex-iNdEx))
			copy(m.SetValue[len(m.SetValue)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRiakDt
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapValue = append(m.MapValue, &MapEntry{})
			if err := m.MapValue[len(m.MapValue)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRiakDt(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRiakDt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRiakDt(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRiakDt
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRiakDt
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRiakDt
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRiakDt
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRiakDt(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRiakDt = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRiakDt   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("riak_dt.proto", fileDescriptorRiakDt) }

var fileDescriptorRiakDt = []byte{
	// 790 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x55, 0xcb, 0x72, 0xe2, 0x46,
	0x14, 0x8d, 0x5e, 0x20, 0xae, 0x04, 0xc6, 0x9d, 0xd8, 0xa6, 0x9c, 0x84, 0x72, 0x94, 0x54, 0xca,
	0xd9, 0x68, 0x41, 0x76, 0x5e, 0xc5, 0x18, 0x70, 0xb9, 0xca, 0xaf, 0x80, 0xed, 0x2d, 0x25, 0x50,
	0x63, 0x53, 0x80, 0x24, 0x4b, 0x2d, 0x7b, 0xf8, 0x80, 0xa9, 0xf9, 0x05, 0x7f, 0xd2, 0xec, 0x66,
	0xe6, 0x0f, 0xa6, 0x66, 0xbe, 0x60, 0xfe, 0x60, 0x6e, 0x77, 0x8b, 0x97, 0xf1, 0x78, 0xa1, 0x2a,
	0xfa, 0xf6, 0x51, 0xdf, 0x73, 0x4e, 0xdf, 0x83, 0xa0, 0x18, 0x0f, 0xbd, 0x51, 0xd7, 0x67, 0x6e,
	0x14, 0x87, 0x2c, 0x74, 0xde, 0x2a, 0x60, 0x9e, 0x79, 0x51, 0x6b, 0x48, 0xc7, 0x3e, 0xb1, 0x41,
	0x0f, 0xbc, 0x09, 0xad, 0x28, 0x7b, 0xea, 0xbe, 0x4d, 0xfe, 0x02, 0x9d, 0x4d, 0x23, 0x5a, 0x51,
	0x71, 0x55, 0xaa, 0x6d, 0xbb, 0x33, 0xd8, 0xfc, 0xc7, 0x15, 0xee, 0x3a, 0x4d, 0xb0, 0x97, 0xd7,
	0xc4, 0x82, 0xfc, 0xd1, 0xc5, 0xf5, 0xf9, 0x55, 0xb3, 0x5d, 0x56, 0x48, 0x1e, 0xb4, 0x4e, 0xf3,
	0xaa, 0xac, 0xe2, 0xc9, 0x66, 0xbb, 0x79, 0x7c, 0xd2, 0xe1, 0x65, 0x8d, 0x98, 0xa0, 0xb7, 0x4e,
	0x0f, 0x8f, 0xcb, 0x3a, 0x07, 0x9c, 0x1d, 0x5e, 0x96, 0x0d, 0xe7, 0x49, 0xf2, 0x68, 0x06, 0x2c,
	0x9e, 0x92, 0x0a, 0x18, 0x03, 0x7e, 0xa0, 0x20, 0x62, 0xd5, 0x0a, 0xf3, 0x8e, 0x64, 0x0b, 0x8a,
	0xfd, 0x30, 0x0d, 0x18, 0x8d, 0xbb, 0x0f, 0xde, 0x38, 0xe5, 0xe4, 0x94, 0x7d, 0x42, 0x36, 0xa1,
	0x90, 0x50, 0x96, 0x95, 0xb4, 0x3d, 0x0d, 0xd9, 0x6f, 0x43, 0x29, 0xa6, 0xb7, 0xc3, 0x64, 0x01,
	0xd5, 0x11, 0x6a, 0x13, 0x02, 0x30, 0x18, 0x7b, 0xb7, 0x59, 0xcd, 0xc0, 0x9a, 0x49, 0x7e, 0x83,
	0xc2, 0xc4, 0x8b, 0xb2, 0x52, 0x0e, 0x5f, 0xcf, 0x7a, 0x0a, 0x36, 0xce, 0x07, 0x05, 0xa0, 0xc1,
	0x5a, 0x94, 0xf5, 0xef, 0xda, 0xf4, 0x9e, 0x94, 0x20, 0xd7, 0x4b, 0xfb, 0x23, 0xca, 0x32, 0x9b,
	0x2c, 0xd0, 0x46, 0x74, 0x2a, 0x5c, 0xb2, 0xb9, 0x83, 0xc2, 0x33, 0x4d, 0xac, 0x0a, 0xa0, 0xc4,
	0xa2, 0x6d, 0x11, 0xbb, 0xaa, 0x51, 0x2c, 0xda, 0x15, 0xc9, 0x2f, 0x60, 0xf7, 0xbc, 0x64, 0xd8,
	0xef, 0xde, 0xa7, 0x61, 0x9c, 0x4e, 0xb0, 0x23, 0x27, 0xf1, 0x33, 0x58, 0x41, 0xc8, 0x06, 0xa8,
	0xce, 0xef, 0x86, 0xa3, 0x4a, 0x5e, 0x14, 0x37, 0x20, 0xcf, 0x86, 0x13, 0x1a, 0xa6, 0xac, 0x62,
	0x8a, 0x77, 0xd1, 0x80, 0x64, 0x1c, 0x46, 0xd1, 0x74, 0xf6, 0x72, 0x41, 0xe0, 0x8a, 0x60, 0x04,
	0x9c, 0x7f, 0x05, 0x04, 0xea, 0x77, 0xd8, 0x18, 0x06, 0xfd, 0x71, 0xea, 0xd3, 0x6e, 0x3f, 0x44,
	0xb7, 0xde, 0xb0, 0x8a, 0xc5, 0x71, 0x07, 0x3a, 0x8b, 0x53, 0xea, 0xfc, 0x0f, 0xf9, 0x06, 0xbb,
	0xe1, 0x6a, 0xd7, 0x0d, 0x55, 0xd6, 0x0d, 0x55, 0x85, 0xa1, 0x2b, 0x26, 0x69, 0xcf, 0x4d, 0x7a,
	0xa7, 0x80, 0x35, 0x37, 0x29, 0x89, 0x38, 0xf1, 0x59, 0x67, 0x45, 0xf8, 0xfe, 0xe7, 0xca, 0x34,
	0x6d, 0xb9, 0x4b, 0x60, 0xb7, 0xe1, 0x31, 0x4f, 0x0c, 0xcf, 0x0e, 0x18, 0xb3, 0xf3, 0x15, 0x3c,
	0xdf, 0x74, 0x33, 0x9a, 0xce, 0x3f, 0x60, 0xce, 0x41, 0x2f, 0x4f, 0x58, 0x36, 0x49, 0x9a, 0x53,
	0x85, 0xc2, 0x91, 0x54, 0x74, 0x11, 0x71, 0x1d, 0x68, 0x44, 0x4c, 0x27, 0x34, 0x90, 0x44, 0x88,
	0xf3, 0x37, 0x18, 0x1d, 0xca, 0x70, 0x0f, 0xef, 0xca, 0xf3, 0xfd, 0x04, 0xcb, 0x5c, 0x1e, 0x12,
	0x46, 0x58, 0xf8, 0x40, 0x13, 0xa9, 0xd7, 0xf9, 0xa4, 0x40, 0x01, 0xe5, 0x5d, 0x47, 0xbe, 0xc7,
	0xe8, 0x2b, 0x23, 0x59, 0x05, 0x98, 0x39, 0x18, 0x46, 0x62, 0x1e, 0xad, 0x1a, 0xb8, 0x0b, 0x0a,
	0xdb, 0x90, 0xe3, 0x56, 0xe2, 0x9e, 0x14, 0x95, 0x73, 0x65, 0x7b, 0xbc, 0xef, 0xf9, 0x80, 0xe2,
	0xa6, 0x9c, 0x4e, 0x07, 0xf2, 0x62, 0x3a, 0xb1, 0xc0, 0x67, 0xa5, 0x54, 0xdb, 0x74, 0xe7, 0x1c,
	0xdc, 0x16, 0xee, 0xc8, 0x03, 0xf9, 0x45, 0x20, 0x24, 0x97, 0x1d, 0x88, 0x90, 0x8b, 0xc8, 0xf9,
	0x03, 0x72, 0x19, 0x02, 0x20, 0xd7, 0x3c, 0x3f, 0xac, 0x9f, 0x36, 0xd1, 0x20, 0x74, 0xab, 0x71,
	0xd2, 0x11, 0x0b, 0xd5, 0xf9, 0x0f, 0x0c, 0x81, 0x25, 0xbb, 0x0b, 0xb5, 0xca, 0xe2, 0x2a, 0xa5,
	0xa0, 0x5f, 0x21, 0x9f, 0x8a, 0x86, 0xd2, 0x09, 0xae, 0x66, 0xce, 0xc1, 0xb9, 0x01, 0xbd, 0xc1,
	0xd9, 0xaf, 0xaa, 0x56, 0x5e, 0x51, 0xad, 0xae, 0xa8, 0x5e, 0x90, 0xd7, 0x56, 0xc8, 0x7f, 0x13,
	0xf3, 0x23, 0x9b, 0xbc, 0x9a, 0x32, 0x65, 0x2d, 0x65, 0x4b, 0xa3, 0x26, 0x4d, 0xdc, 0x04, 0x55,
	0xf8, 0xc7, 0x2f, 0xca, 0x70, 0x05, 0x5d, 0x4c, 0xe2, 0xa3, 0xb0, 0x4b, 0x24, 0xd1, 0x7f, 0x14,
	0xf1, 0x92, 0xa9, 0x7c, 0xcc, 0x92, 0xb5, 0xcb, 0xef, 0x83, 0xa5, 0x71, 0xd0, 0xed, 0x85, 0xfe,
	0x54, 0xe6, 0xea, 0xc0, 0x18, 0x78, 0xe3, 0x84, 0x2e, 0xc7, 0x10, 0x5e, 0x8e, 0xa1, 0xb5, 0x1a,
	0x43, 0xfb, 0x47, 0x31, 0x2c, 0x2e, 0xc5, 0x90, 0x81, 0xbd, 0x90, 0x8c, 0x99, 0xc9, 0x34, 0xca,
	0xbc, 0x2c, 0xa9, 0x92, 0xa2, 0xd7, 0x92, 0xaa, 0xad, 0x27, 0x55, 0x5f, 0x4f, 0xaa, 0xf1, 0x2c,
	0xa9, 0xf5, 0x7f, 0xdf, 0x7f, 0xa9, 0x2a, 0x1f, 0xf1, 0xf9, 0x8c, 0xcf, 0xd3, 0xd7, 0xea, 0x4f,
	0xb0, 0xd3, 0x0f, 0x27, 0x2e, 0xfe, 0x23, 0xdd, 0x85, 0x2e, 0xff, 0x38, 0xc8, 0x2f, 0x43, 0x2f,
	0x1d, 0xd4, 0xcd, 0x36, 0x2e, 0x1b, 0xec, 0xb2, 0xfe, 0x3d, 0x00, 0x00, 0xff, 0xff, 0x1d, 0x46,
	0x2a, 0x99, 0x36, 0x06, 0x00, 0x00,
}
